<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · VoronoiFVM.jl</title><meta name="title" content="Solvers · VoronoiFVM.jl"/><meta property="og:title" content="Solvers · VoronoiFVM.jl"/><meta property="twitter:title" content="Solvers · VoronoiFVM.jl"/><meta name="description" content="Documentation for VoronoiFVM.jl."/><meta property="og:description" content="Documentation for VoronoiFVM.jl."/><meta property="twitter:description" content="Documentation for VoronoiFVM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VoronoiFVM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../changes/">Changelog</a></li><li><a class="tocitem" href="../method/">The Voronoi finite volume method</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../system/">System</a></li><li><a class="tocitem" href="../physics/">Physics &amp; special functions</a></li><li><a class="tocitem" href="../solutions/">Solution objects</a></li><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#Built-in-solver"><span>Built-in solver</span></a></li><li><a class="tocitem" href="#diffeq"><span>OrdinaryDiffEq.jl transient solver</span></a></li><li><a class="tocitem" href="#Legacy-API"><span>Legacy API</span></a></li></ul></li><li><a class="tocitem" href="../post/">Postprocessing</a></li><li><a class="tocitem" href="../quantities/">Quantities</a></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../internal/">Internal API</a></li><li><a class="tocitem" href="../allindex/">Index</a></li><li><a class="tocitem" href="../devel/">Development hints</a></li></ul></li><li><span class="tocitem">Tutorial Notebooks</span><ul><li><a class="tocitem" href="../notebooks/">About the notebooks</a></li><li><a class="tocitem" href="../plutostatichtml_examples/ode-diffusion1d/">OrdinaryDiffEq.jl nonlinear diffusion</a></li><li><a class="tocitem" href="../plutostatichtml_examples/ode-wave1d/">OrdinaryDiffEq.jl 1D wave equation</a></li><li><a class="tocitem" href="../plutostatichtml_examples/ode-nlstorage1d/">OrdinaryDiffEq.jl changing mass matrix</a></li><li><a class="tocitem" href="../plutostatichtml_examples/ode-brusselator/">OrdinaryDiffEq.jl brusselator</a></li><li><a class="tocitem" href="../plutostatichtml_examples/heterogeneous-catalysis/">Coupling with Catalyst.jl</a></li><li><a class="tocitem" href="../plutostatichtml_examples/outflow/">Outflow boundary conditions</a></li><li><a class="tocitem" href="../plutostatichtml_examples/flux-reconstruction/">Obtaining vector fields</a></li><li><a class="tocitem" href="../plutostatichtml_examples/interfaces1d/">Internal interfaces (1D)</a></li><li><a class="tocitem" href="../plutostatichtml_examples/problemcase/">A case for caution</a></li><li><a class="tocitem" href="../plutostatichtml_examples/nonlinear-solvers/">Nonlinear solver control</a></li><li><a class="tocitem" href="../plutostatichtml_examples/bernoulli/">Bernoulli function test</a></li><li><a class="tocitem" href="../plutostatichtml_examples/api-update/">API Updates</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../runexamples/">About the examples</a></li><li><a class="tocitem" href="../module_examples/Example001_Solvers/">001: New linear solver API</a></li><li><a class="tocitem" href="../module_examples/Example002_EdgeReaction/">002: check edge reaction</a></li><li><a class="tocitem" href="../module_examples/Example101_Laplace1D/">101: 1D Laplace equation</a></li><li><a class="tocitem" href="../module_examples/Example102_StationaryConvectionDiffusion1D/">102: 1D Stationary convection-diffusion equation</a></li><li><a class="tocitem" href="../module_examples/Example103_ConvectionDiffusion1D/">103: 1D Convection-diffusion equation</a></li><li><a class="tocitem" href="../module_examples/Example105_NonlinearPoisson1D/">105: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../module_examples/Example106_NonlinearDiffusion1D/">106: 1D Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../module_examples/Example107_NonlinearStorage1D/">107: 1D Nonlinear Storage</a></li><li><a class="tocitem" href="../module_examples/Example108_OrdinaryDiffEq1D/">108: 1D Nonlinear Diffusion equation with ODE</a></li><li><a class="tocitem" href="../module_examples/Example110_ReactionDiffusion1D_TwoSpecies/">110: 1D Reaction Diffusion equation with two species</a></li><li><a class="tocitem" href="../module_examples/Example115_HeterogeneousCatalysis1D/">115: 1D heterogeneous catalysis</a></li><li><a class="tocitem" href="../module_examples/Example120_ThreeRegions1D/">120: Differing species sets in regions, 1D</a></li><li><a class="tocitem" href="../module_examples/Example121_PoissonPointCharge1D/">121: 1D Poisson with point charge</a></li><li><a class="tocitem" href="../module_examples/Example125_TestFunctions1D/">125: Terminal flux calculation via test functions</a></li><li><a class="tocitem" href="../module_examples/Example150_Impedance1D/">150: Impedance calculation</a></li><li><a class="tocitem" href="../module_examples/Example151_Impedance1D/">151: Impedance calculation</a></li><li><a class="tocitem" href="../module_examples/Example160_UnipolarDriftDiffusion1D/">160: Unipolar degenerate drift-diffusion</a></li><li><a class="tocitem" href="../module_examples/Example201_Laplace2D/">201: 2D Laplace equation</a></li><li><a class="tocitem" href="../module_examples/Example203_CoordinateSystems/">203: Various coordinate systems</a></li><li><a class="tocitem" href="../module_examples/Example204_HagenPoiseuille/">204: 2D Convection in Hagen-Poiseuille flow</a></li><li><a class="tocitem" href="../module_examples/Example205_StagnationPoint/">205: Convection in axisymmetric stagnation point flow</a></li><li><a class="tocitem" href="../module_examples/Example206_JouleHeat/">206: 2D Joule heating</a></li><li><a class="tocitem" href="../module_examples/Example207_NonlinearPoisson2D/">207: 2D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../module_examples/Example210_NonlinearPoisson2D_Reaction/">210: 2D Nonlinear Poisson with reaction</a></li><li><a class="tocitem" href="../module_examples/Example215_NonlinearPoisson2D_BoundaryReaction/">215: 2D Nonlinear Poisson with boundary reaction</a></li><li><a class="tocitem" href="../module_examples/Example220_NonlinearPoisson2D_BoundarySpecies/">220: 2D Nonlinear Poisson with boundary reaction and boundary species</a></li><li><a class="tocitem" href="../module_examples/Example221_EquationBlockPrecon/">221: Equation block preconditioning</a></li><li><a class="tocitem" href="../module_examples/Example225_TestFunctions2D/">225: Terminal flux calculation via test functions, nD</a></li><li><a class="tocitem" href="../module_examples/Example226_BoundaryIntegral/">226: Terminal flux calculation via test functions, nD, boundary reaction</a></li><li><a class="tocitem" href="../module_examples/Example230_BoundaryFlux/">103: Boundary flux</a></li><li><a class="tocitem" href="../module_examples/Example301_Laplace3D/">301: 3D Laplace equation</a></li><li><a class="tocitem" href="../module_examples/Example311_HeatEquation_BoundaryDiffusion/">311: Heat Equation with boundary diffusion</a></li><li><a class="tocitem" href="../module_examples/Example405_GenericOperator/">405: Generic operator</a></li><li><a class="tocitem" href="../module_examples/Example406_WeirdReaction/">406: 1D Weird Surface Reaction</a></li><li><a class="tocitem" href="../module_examples/Example410_ManySpecies/">410: Many Species</a></li><li><a class="tocitem" href="../module_examples/Example420_DiscontinuousQuantities/">420: Discontinuous Quantities</a></li><li><a class="tocitem" href="../module_examples/Example421_AbstractQuantities_TestFunctions/">421: Current Calculation for AbstractQuantities</a></li><li><a class="tocitem" href="../module_examples/Example422_InterfaceQuantities/">422: Drift-Diffusion with Discontinuous and Interface Potentials</a></li><li><a class="tocitem" href="../module_examples/Example424_AbstractQuantitiesInit/">424: Initialization of Abstract quantities</a></li><li><a class="tocitem" href="../module_examples/Example430_ParameterDerivativesStationary/">430: Parameter Derivatives (stationary)</a></li><li><a class="tocitem" href="../module_examples/Example440_ParallelState/">440: Parallel solves</a></li><li><a class="tocitem" href="../module_examples/Example510_Mixture/">510: Mixture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/j-fu/VoronoiFVM.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h1><p>The package comes with a <a href="#Built-in-solver">built-in solve method</a> which solves  stationary problems, homotopy embedding problems and transient problems  via the implicit Euler method. In particular, the transient solver allows to use nonlinear storage terms.</p><p>Alternatively, <a href="#diffeq">OrdinaryDiffEq.jl based solvers</a> can be used  for transient problems.</p><h2 id="Built-in-solver"><a class="docs-heading-anchor" href="#Built-in-solver">Built-in solver</a><a id="Built-in-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-solver" title="Permalink"></a></h2><p>This solver and its default parameters are tuned for robustness, possibly at the expense of solution speed. Careful tuning of the parameters, or – in the case of transient problems – the choice of a <a href="#diffeq">OrdinaryDiffEq.jl based solver</a> can significantly improve the performance.</p><p>Overview:</p><ul><li><a href="#Solve-method">Solve method</a></li><li><a href="#Solver-control">Solver control</a></li><li><a href="#System-state">System state</a></li><li><a href="#Linear-solver-strategies">Linear solver stragies</a></li><li><a href="#Block-preconditioning">Block preconditioning</a></li><li><a href="#History-handling">History handling</a></li><li><a href="#Matrix-extraction">Matrix extraction</a></li></ul><h3 id="Solve-method"><a class="docs-heading-anchor" href="#Solve-method">Solve method</a><a id="Solve-method-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-method" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}" href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve(system; kwargs...)</code></pre><p>Built-in solution method for <a href="../system/#VoronoiFVM.System"><code>VoronoiFVM.System</code></a>.  </p><p>Keyword arguments:</p><ul><li><p>General for all solvers </p><ul><li><code>inival</code> (default: 0) : Array created via <a href="../post/#VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.ImpedanceSystem{Tv}}, Tuple{Tv}} where Tv"><code>unknowns</code></a> or  number giving the initial value.</li><li><code>control</code> (default: nothing): Pass instance of <a href="../plutostatichtml_examples/nonlinear-solvers/#SolverControl"><code>SolverControl</code></a></li><li>All elements of <a href="../plutostatichtml_examples/nonlinear-solvers/#SolverControl"><code>SolverControl</code></a> can be used as kwargs. Eventually overwrites values given via <code>control</code></li><li><code>params</code>: Parameters (Parameter handling is experimental and may change)</li></ul></li><li><p><strong>Stationary solver</strong>: Invoked if neither <code>times</code> nor <code>embed</code>, nor <code>tstep</code> are given as keyword argument.</p><ul><li><code>time</code> (default: <code>0.0</code>): Set time value.</li></ul><p>Returns a <a href="../solutions/#VoronoiFVM.DenseSolutionArray"><code>DenseSolutionArray</code></a> or <a href="../solutions/#VoronoiFVM.SparseSolutionArray"><code>SparseSolutionArray</code></a></p></li><li><p><strong>Embedding (homotopy) solver</strong>: Invoked if <code>embed</code> kwarg is given. Use homotopy embedding + damped Newton&#39;s method  to  solve stationary problem or to solve series of parameter dependent problems. Parameter step control is performed according to solver control data.  kwargs and default values are:</p><ul><li><code>embed</code> (default: <code>nothing</code> ): vector of parameter values to be reached exactly</li></ul><p>In addition,  all kwargs of the implicit Euler solver (besides <code>times</code>) are handled.   Returns a transient solution object <code>sol</code> containing the stored solution(s),  see <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p></li><li><p><strong>Implicit Euler transient solver</strong>: Invoked if <code>times</code> kwarg is given. Use implicit Euler method  + damped   Newton&#39;s method  to  solve time dependent problem. Time step control is performed according to solver control data.  kwargs and default values are:</p><ul><li><code>times</code> (default: <code>nothing</code> ): vector of time values to be reached exactly</li><li><code>pre</code> (default: <code>(sol,t)-&gt;nothing</code> ):  callback invoked before each time step</li><li><code>post</code>  (default:  <code>(sol,oldsol, t, Δt)-&gt;nothing</code> ): callback invoked after each time step</li><li><code>sample</code> (default:  <code>(sol,t)-&gt;nothing</code> ): callback invoked after timestep for all times in <code>times[2:end]</code>.</li><li><code>delta</code> (default:  <code>(system, u,v,t, Δt)-&gt;norm(sys,u-v,Inf)</code> ):  Value  used to control the time step size <code>Δu</code></li></ul><p>If <code>control.handle_error</code> is true, if time step solution  throws an error, stepsize  is lowered, and  step solution is called again with a smaller time value. If <code>control.Δt&lt;control.Δt_min</code>, solution is aborted with error. Returns a transient solution object <code>sol</code> containing the stored solution,  see <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p></li><li><p><strong>Implicit Euler timestep solver</strong>.  Invoked if <code>tstep</code> kwarg is given. Solve one time step of the implicit Euler method.</p><ul><li><code>time</code> (default: <code>0</code>): Set time value. </li><li><code>tstep</code>: time step</li></ul><p>Returns a <a href="../solutions/#VoronoiFVM.DenseSolutionArray"><code>DenseSolutionArray</code></a> or <a href="../solutions/#VoronoiFVM.SparseSolutionArray"><code>SparseSolutionArray</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h3 id="Solver-control"><a class="docs-heading-anchor" href="#Solver-control">Solver control</a><a id="Solver-control-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-control" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.SolverControl" href="#VoronoiFVM.SolverControl"><code>VoronoiFVM.SolverControl</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SolverControl
SolverControl(;kwargs...)
SolverControl(linear_solver_strategy, sys; kwargs...)</code></pre><p>Solver control parameter for time stepping, embedding, Newton method and linear solver control. All field names can be used as keyword arguments for <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>solve(system::VoronoiFVM.AbstractSystem; kwargs...)</code></a></p><p>Newton&#39;s method solves <span>$F(u)=0$</span> by the iterative procedure <span>$u_{i+1}=u_{i} - d_i F&#39;(u_i)^{-1}F(u_i)$</span> starting with some initial value <span>$u_0$</span>, where <span>$d_i$</span> is a damping parameter.</p><p>For linear solver strategies, see <a href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a>.</p><ul><li><code>verbose::Union{Bool, String}</code>: Verbosity control. A collection of output categories is given in a string composed of the following letters:<ul><li>a: allocation warnings</li><li>d: deprecation warnings</li><li>e: time/parameter evolution log</li><li>n: newton solver log</li><li>l: linear solver log</li></ul>Alternatively, a Bool value can be given, resulting in<ul><li>true: &quot;neda&quot;</li><li>false: &quot;da&quot;</li></ul>Switch off all output including deprecation warnings via <code>verbose=&quot;&quot;</code>. In the output, corresponding messages are marked e.g. via &#39;[n]&#39;, <code>[a]</code> etc. (besides of &#39;[l]&#39;)</li></ul><ul><li><code>abstol::Float64</code>: Tolerance (in terms of norm of Newton update): terminate if <span>$\Delta u_i=||u_{i+1}-u_i||_\infty &lt;$</span> <code>abstol</code>.</li></ul><ul><li><code>reltol::Float64</code>: Tolerance (relative to the size of the first update): terminate if <span>$\Delta u_i/\Delta u_1&lt;$</span> <code>reltol</code>.</li></ul><ul><li><code>maxiters::Int64</code>: Maximum number of newton iterations.</li></ul><ul><li><code>tol_round::Float64</code>: Tolerance for roundoff error detection: terminate if   <span>$|\;||u_{i+1}||_1 - ||u_{i}||_1\;|/ ||u_{i}||_1&lt;$</span> <code>tol_round</code> occurred <code>max_round</code> times in a row.</li></ul><ul><li><code>tol_mono::Float64</code>: Tolerance for monotonicity test: terminate with error if <span>$\Delta u_i/\Delta u_{i-1}&gt;$</span> <code>1/tol_mono</code>.</li></ul><ul><li><code>damp_initial::Float64</code>: Initial damping parameter <span>$d_0$</span>. To handle convergence problems, set this to a value less than 1.</li></ul><ul><li><code>damp_growth::Float64</code>: Damping parameter growth factor: <span>$d_{i+1}=\min(d_i\cdot$</span> <code>max_growth</code> <span>$,1)$</span>. It should be larger than 1.</li></ul><ul><li><code>max_round::Int64</code>: Maximum number of consecutive iterations within roundoff error tolerance The default effectively disables this criterion.</li></ul><ul><li><code>unorm::Function</code>: Calculation of Newton update norm</li></ul><ul><li><code>rnorm::Function</code>: Functional for roundoff error calculation</li></ul><ul><li><p><code>method_linear::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm}</code>: Solver method for linear systems (see LinearSolve.jl). If given <code>nothing</code>, as default are chosen:</p><ul><li><code>UMFPACKFactorization()</code> for sparse matrices with Float64</li><li><code>SparspakFactorization()</code> for sparse matrices with  general number types.</li><li>Defaults from LinearSolve.jl for tridiagonal and banded matrices</li></ul><p>Users should experiment with what works best for their problem.</p><p>For an overeview on possible alternatives, see <a href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a>.</p></li></ul><ul><li><code>reltol_linear::Float64</code>:     Relative tolerance of iterative linear solver.</li></ul><ul><li><code>abstol_linear::Float64</code>: Absolute tolerance of iterative linear solver.</li></ul><ul><li><code>maxiters_linear::Int64</code>: Maximum number of iterations of linear solver</li></ul><ul><li><p><code>precon_linear::Union{Nothing, Function, ExtendableSparse.AbstractFactorization, LinearSolve.SciMLLinearSolveAlgorithm, Type}</code>: Constructor for preconditioner for linear systems. This should work as a function <code>precon_linear(A)</code> which takes an AbstractSparseMatrixCSC (e.g. an ExtendableSparseMatrix) and returns a preconditioner object in the sense of <code>LinearSolve.jl</code>, i.e. which has an <code>ldiv!(u,A,v)</code> method. Useful examples:</p><ul><li><code>ExtendableSparse.ILUZero</code></li><li><code>ExtendableSparse.Jacobi</code></li></ul><p>For easy access to this functionality, see see also <a href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a>.</p></li></ul><ul><li><code>keepcurrent_linear::Bool</code>: Update preconditioner in each Newton step ?</li></ul><ul><li><code>Δp::Float64</code>: Initial parameter step for embedding.</li></ul><ul><li><code>Δp_max::Float64</code>: Maximal parameter step size.</li></ul><ul><li><code>Δp_min::Float64</code>: Minimal parameter step size.</li></ul><ul><li><code>Δp_grow::Float64</code>: Maximal parameter step size growth.</li></ul><ul><li><code>Δp_decrease::Float64</code>: Parameter step decrease factor upon rejection</li></ul><ul><li><code>Δt::Float64</code>: Initial time step  size.</li></ul><ul><li><code>Δt_max::Float64</code>: Maximal time step size.</li></ul><ul><li><code>Δt_min::Float64</code>: Minimal time step size.</li></ul><ul><li><code>Δt_grow::Float64</code>: Maximal time step size growth.</li></ul><ul><li><code>Δt_decrease::Float64</code>: Time step decrease factor upon rejection</li></ul><ul><li><code>Δu_opt::Float64</code>: Optimal size of update for time stepping and embedding. The algorithm tries to keep the difference in norm between &quot;old&quot; and &quot;new&quot; solutions  approximately at this value.</li></ul><ul><li><code>Δu_max_factor::Float64</code>: Control maximum  sice of update <code>Δu</code> for time stepping and embeding relative to <code>Δu_opt</code>. Time steps with <code>Δu &gt; Δu_max_factor*Δu_opt</code> will be rejected.</li></ul><ul><li><code>force_first_step::Bool</code>: Force first timestep.</li></ul><ul><li><code>num_final_steps::Int64</code>: Number of final steps to adjust at end of time interval in order to prevent breakdown of step size.</li></ul><ul><li><p><code>handle_exceptions::Bool</code>: Handle exceptions during transient solver and parameter embedding. If <code>true</code>, exceptions in Newton solves are caught, the embedding resp. time step is lowered, and solution is retried. Moreover, if embedding or time stepping fails (e.g. due to reaching minimal step size), a warning is issued, and a solution is returned with all steps calculated so far.</p><p>Otherwise (by default) errors are thrown.</p></li></ul><ul><li><code>store_all::Bool</code>: Store all steps of transient/embedding problem:</li></ul><ul><li><code>in_memory::Bool</code>: Store transient/embedding solution in memory</li></ul><ul><li><code>log::Any</code>:    Record history</li></ul><ul><li><code>edge_cutoff::Float64</code>: Edge parameter cutoff for rectangular triangles.</li></ul><ul><li><code>pre::Function</code>: Function <code>pre(sol,t)</code> called before time/embedding step</li></ul><ul><li><code>post::Function</code>: Function <code>post(sol,oldsol,t,Δt)</code> called after successful time/embedding step</li></ul><ul><li><code>sample::Function</code>: Function <code>sample(sol,t)</code> to be called for each <code>t in times[2:end]</code></li></ul><ul><li><code>delta::Function</code>: Time step error estimator. A function <code>Δu=delta(system,u,uold,t,Δt)</code> to calculate <code>Δu</code>.</li></ul><ul><li><p><code>tol_absolute::Union{Nothing, Float64}</code></p></li><li><p><code>tol_relative::Union{Nothing, Float64}</code></p></li><li><p><code>damp::Union{Nothing, Float64}</code></p></li><li><p><code>damp_grow::Union{Nothing, Float64}</code></p></li><li><p><code>max_iterations::Union{Nothing, Int64}</code></p></li><li><p><code>tol_linear::Union{Nothing, Float64}</code></p></li><li><p><code>max_lureuse::Union{Nothing, Int64}</code></p></li><li><p><code>mynorm::Union{Nothing, Function}</code></p></li><li><p><code>myrnorm::Union{Nothing, Function}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.fixed_timesteps!" href="#VoronoiFVM.fixed_timesteps!"><code>VoronoiFVM.fixed_timesteps!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fixed_timesteps!(control,Δt; grow=1.0)</code></pre><p>Modify control data such that the time steps are fixed to a geometric sequence such that Δt<em>new=Δt</em>old*grow</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h3 id="System-state"><a class="docs-heading-anchor" href="#System-state">System state</a><a id="System-state-1"></a><a class="docs-heading-anchor-permalink" href="#System-state" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.SystemState" href="#VoronoiFVM.SystemState"><code>VoronoiFVM.SystemState</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct SystemState{Tv, TMatrix&lt;:AbstractArray{Tv, 2}, TSolArray&lt;:AbstractArray{Tv, 2}, TData}</code></pre><p>Structure holding state information for finite volume system.</p><p>Type parameters:</p><ul><li>Tv: element type of solution vectors and matrix</li><li>TMatrix:  matrix type</li><li>TSolArray: type of solution vector: (Matrix or SparseMatrixCSC)</li><li>TData: type of user data</li></ul><p>Type fields:</p><ul><li><code>system::VoronoiFVM.System</code>: Related finite volume system</li></ul><ul><li><code>data::Any</code>: Parameter data</li></ul><ul><li><code>solution::AbstractMatrix</code>: Solution vector</li></ul><ul><li><code>matrix::AbstractMatrix</code>: Jacobi matrix for nonlinear problem</li></ul><ul><li><code>dudp::Vector{TSolArray} where {Tv, TSolArray&lt;:AbstractMatrix{Tv}}</code>: Parameter derivative (vector of solution arrays)</li></ul><ul><li><code>update::AbstractMatrix</code>: Vector holding Newton update</li></ul><ul><li><code>residual::AbstractMatrix</code>: Vector holding Newton residual</li></ul><ul><li><code>linear_cache::Union{Nothing, LinearSolve.LinearCache}</code>: Linear solver cache</li></ul><ul><li><code>uhash::UInt64</code>: Hash value of latest unknowns vector the assembly was called with (used by differential equation interface)</li></ul><ul><li><code>history::Union{Nothing, VoronoiFVM.DiffEqHistory}</code>: History record for solution process (used by differential equation interface)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.SystemState-Tuple{Type, VoronoiFVM.AbstractSystem}" href="#VoronoiFVM.SystemState-Tuple{Type, VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.SystemState</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SystemState(Tv, system; data=system.physics.data, matrixtype=system.matrixtype)</code></pre><p>Create state information for finite volume system.</p><p>Arguments:</p><ul><li><code>Tv</code>: value type of unknowns, matrix</li><li><code>system</code>: Finite volume system</li></ul><p>Keyword arguments:</p><ul><li><code>data</code>: User data. Default: <code>data(system)</code></li><li><code>matrixtype</code>. Default: <code>system.matrixtype</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.SystemState-Tuple{VoronoiFVM.AbstractSystem}" href="#VoronoiFVM.SystemState-Tuple{VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.SystemState</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SystemState(Tv, system; data=system.physics.data, matrixtype=system.matrixtype)</code></pre><p>Create state information for finite volume system.</p><p>Arguments:</p><ul><li><code>Tv</code>: value type of unknowns, matrix</li><li><code>system</code>: Finite volume system</li></ul><p>Keyword arguments:</p><ul><li><code>data</code>: User data. Default: <code>data(system)</code></li><li><code>matrixtype</code>. Default: <code>system.matrixtype</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section><section><div><pre><code class="language-julia hljs">SystemState(system; kwargs...)</code></pre><p>Shortcut for creating state with value type defined by <code>Tv</code> type parameter of system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CommonSolve.solve!-Tuple{VoronoiFVM.SystemState}" href="#CommonSolve.solve!-Tuple{VoronoiFVM.SystemState}"><code>CommonSolve.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve!(state; kwargs...)</code></pre><p>Built-in solution method for <a href="../system/#VoronoiFVM.System"><code>VoronoiFVM.System</code></a>.  </p><p>Solves finite volume system the satate is belonging to. Mutates the state and returns the solution.</p><p>For the keyword argumentsm see <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.similar-Tuple{VoronoiFVM.SystemState}" href="#Base.similar-Tuple{VoronoiFVM.SystemState}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">similar(state; data=state.data)</code></pre><p>Create a new state of with the same system, different work arrays, and possibly different data. The matrix of the new state initially shares the sparsity structure with <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h3 id="Linear-solver-strategies"><a class="docs-heading-anchor" href="#Linear-solver-strategies">Linear solver strategies</a><a id="Linear-solver-strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solver-strategies" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.LinearSolverStrategy" href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VoronoiFVM.LinearSolverStrategy</code></pre><p>An linear solver strategy provides the possibility to construct <a href="../plutostatichtml_examples/nonlinear-solvers/#SolverControl"><code>SolverControl</code></a> objects as follows:</p><pre><code class="nohighlight hljs">    SolverControl(strategy,sys;kwargs...)</code></pre><p>, e.g.</p><pre><code class="nohighlight hljs">    SolverControl(GMRESIteration(UMFPackFactorization(), EquationBlock()),sys; kwargs...)</code></pre><p>A linear solver strategy combines a Krylov method  with a preconditioner which by default is calculated from the linearization of the initial value of the Newton iteration. For coupled systems, a blocking strategy can be chosen. The <a href="#VoronoiFVM.EquationBlock"><code>EquationBlock</code></a> strategy calculates preconditioners or LU factorization  separately for each species equation and combines them to a block Jacobi preconditioner.  The <a href="#VoronoiFVM.PointBlock"><code>PointBlock</code></a> strategy treats the linear system as consisting of <code>nspecies x nspecies</code> blocks. </p><p>Which is the best strategy, depends on the space dimension. The following is a rule of thumb for choosing strategies</p><ul><li>For 1D problems use direct solvers</li><li>For 2D stationary problems, use direct solvers, for transient problems consider iterative solvers which  can take advantage of the diagonal dominance of the implicit timestep problem</li><li>For 3D problems avoid direct solvers</li></ul><p>Currently available strategies are:</p><ul><li><a href="#VoronoiFVM.DirectSolver"><code>DirectSolver</code></a></li><li><a href="#VoronoiFVM.CGIteration"><code>CGIteration</code></a></li><li><a href="#VoronoiFVM.BICGstabIteration"><code>BICGstabIteration</code></a></li><li><a href="#VoronoiFVM.GMRESIteration"><code>GMRESIteration</code></a></li></ul><p>Notable LU Factorizations/direct solvers are:</p><ul><li><a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#SuiteSparse.jl"><code>UMFPACKFactorization</code></a>  (<code>using LinearSolve</code>)</li><li><a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#SuiteSparse.jl"><code>KLUFactorization</code></a> (<code>using LinearSolve</code>)</li><li><a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#Sparspak.jl"><code>SparspakFactorization</code></a>  (<code>using LinearSolve</code>), <a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.SparspakLU"><code>SparspakLU</code></a> (<code>using ExtendableSparse,Sparspak</code>)</li><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.MKLPardisoLU"><code>MKLPardisoLU</code></a> (<code>using ExtendableSparse, Pardiso</code>), openmp parallel</li><li><a href="https://j-fu.github.io/AMGCLWrap.jl/stable/solvers/#AMGCLWrap.AMGSolver"><code>AMGSolver</code></a> (<code>using AMGCLWrap</code>), openmp parallel</li><li><a href="https://j-fu.github.io/AMGCLWrap.jl/stable/solvers/#AMGCLWrap.RLXSolver"><code>RLXSolver</code></a> (<code>using AMGCLWrap</code>), openmp parallel</li></ul><p>Notable incomplete factorizations/preconditioners</p><ul><li>Incomplete LU factorizations written in Julia:<ul><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.ILUZeroPreconditioner"><code>ILUZeroPreconditioner</code></a></li><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.ILUTPreconditioner"><code>ILUTPrecondidtioner</code></a> (<code>using ExtendableSparse, IncompleteLU</code>)</li></ul></li><li>Algebraic multigrid written in Julia: (<code>using ExtendableSparse, AlgebraicMultigrid</code>)<ul><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.RS_AMGPreconditioner"><code>RS_AMGPreconditioner</code></a></li><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.SA_AMGPreconditioner"><code>SA_AMGPreconditioner</code></a></li></ul></li><li>AMGCL based preconditioners (<code>using ExtendableSparse, AMGCLWrap</code>), openmp parallel<ul><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.AMGCL_AMGPreconditioner"><code>AMGCL_AMGPreconditioner</code></a></li><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.AMGCL_RLXPreconditioner"><code>AMGCL_RLXPreconditioner</code></a></li></ul></li></ul><p>Blocking strategies are:</p><ul><li><a href="#VoronoiFVM.NoBlock"><code>NoBlock</code></a></li><li><a href="#VoronoiFVM.EquationBlock"><code>EquationBlock</code></a></li><li><a href="#VoronoiFVM.PointBlock"><code>PointBlock</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.DirectSolver" href="#VoronoiFVM.DirectSolver"><code>VoronoiFVM.DirectSolver</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DirectSolver(;factorization=UMFPACKFactorization())</code></pre><p>LU Factorization solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.CGIteration" href="#VoronoiFVM.CGIteration"><code>VoronoiFVM.CGIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CGIteration(;factorization=UMFPACKFactorization())
CGIteration(factorization)</code></pre><p>CG Iteration from Krylov.jl via LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.BICGstabIteration" href="#VoronoiFVM.BICGstabIteration"><code>VoronoiFVM.BICGstabIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BICGstabIteration(;factorization=UMFPACKFactorization())
BICGstabIteration(factorization)</code></pre><p>BICGstab Iteration from Krylov.jl via LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.GMRESIteration" href="#VoronoiFVM.GMRESIteration"><code>VoronoiFVM.GMRESIteration</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GMRESIteration(;factorization=ILUZeroFactorization(), memory=20, restart=true)
GMRESIteration(factorization; memory=20, restart=true)</code></pre><p>GMRES Iteration from Krylov.jl via LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h3 id="Block-preconditioning"><a class="docs-heading-anchor" href="#Block-preconditioning">Block preconditioning</a><a id="Block-preconditioning-1"></a><a class="docs-heading-anchor-permalink" href="#Block-preconditioning" title="Permalink"></a></h3><p>This feature is under development as of 1.6.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.BlockStrategy" href="#VoronoiFVM.BlockStrategy"><code>VoronoiFVM.BlockStrategy</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VoronoiFVM.BlockStrategy</code></pre><p>Abstract supertype for various block preconditioning strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.NoBlock" href="#VoronoiFVM.NoBlock"><code>VoronoiFVM.NoBlock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NoBlock()</code></pre><p>No blocking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.EquationBlock" href="#VoronoiFVM.EquationBlock"><code>VoronoiFVM.EquationBlock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EquationBlock()</code></pre><p>Equation-wise blocking. Can be combined with any preconditioner resp. factorization including direct solvers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.PointBlock" href="#VoronoiFVM.PointBlock"><code>VoronoiFVM.PointBlock</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PointBlock()</code></pre><p>Point-wise blocking. Currently only together with ILUZeroFactorization. This requires a system with <code>unknown_storage=:dense</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.Equationwise" href="#VoronoiFVM.Equationwise"><code>VoronoiFVM.Equationwise</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Equationwise</code></pre><p>Equationwise partitioning mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.partitioning" href="#VoronoiFVM.partitioning"><code>VoronoiFVM.partitioning</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partitioning(system, _)
</code></pre><p>Calculate partitioning of system unknowns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h3 id="History-handling"><a class="docs-heading-anchor" href="#History-handling">History handling</a><a id="History-handling-1"></a><a class="docs-heading-anchor-permalink" href="#History-handling" title="Permalink"></a></h3><p>If <code>log</code> is set to true in <code>solve</code>, the history of newton iterations and  time/embedding steps is recorded and returned as <code>history(solution)</code></p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.NewtonSolverHistory" href="#VoronoiFVM.NewtonSolverHistory"><code>VoronoiFVM.NewtonSolverHistory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct NewtonSolverHistory &lt;: AbstractVector{Float64}</code></pre><p>History information for one Newton solve of a nonlinear system. As an abstract vector it provides the history of the update norms. See <a href="#Base.summary-Tuple{NewtonSolverHistory}"><code>summary</code></a> and <a href="#VoronoiFVM.details"><code>details</code></a> for other ways to extract information.</p><ul><li><p><code>nlu::Int64</code>:  number of Jacobi matrix factorizations</p></li><li><p><code>nlin::Int64</code>:  number of linear iteration steps / factorization solves</p></li><li><p><code>time::Float64</code>:  Elapsed time for solution</p></li><li><p><code>tasm::Float64</code>:  Elapsed time for assembly</p></li><li><p><code>tlinsolve::Float64</code>:  Elapsed time for linear solve</p></li><li><p><code>updatenorm::Any</code>:  History of norms of <span>$||u_{i+1}-u_i||$</span></p></li><li><p><code>l1normdiff::Any</code>:  History of norms of <span>$|\;||u_{i+1}||_1 - ||u_{i}||_1\;|/ ||u_{i}||_1$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.TransientSolverHistory" href="#VoronoiFVM.TransientSolverHistory"><code>VoronoiFVM.TransientSolverHistory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct TransientSolverHistory &lt;: AbstractVector{NewtonSolverHistory}</code></pre><p>History information for transient solution/parameter embedding</p><p>As an abstract vector it provides the histories of each implicit Euler/embedding step. See <a href="#Base.summary-Tuple{NewtonSolverHistory}"><code>summary</code></a> and <a href="#VoronoiFVM.details"><code>details</code></a> for other ways to extract information.</p><ul><li><p><code>histories::Any</code>:  Histories of each implicit Euler Newton iteration</p></li><li><p><code>times::Any</code>:  Time values</p></li><li><p><code>updates::Any</code>:  Update norms used for step control</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.DiffEqHistory" href="#VoronoiFVM.DiffEqHistory"><code>VoronoiFVM.DiffEqHistory</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct DiffEqHistory</code></pre><p>History information for DiffEqHistory</p><ul><li><p><code>nd::Any</code>:  number of combined jacobi/rhs evaluations</p></li><li><p><code>njac::Any</code>:  number of combined jacobi evaluations</p></li><li><p><code>nf::Any</code>:  number of rhs evaluations</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.summary-Tuple{NewtonSolverHistory}" href="#Base.summary-Tuple{NewtonSolverHistory}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">summary(h::NewtonSolverHistory)</code></pre><p>Return named tuple summarizing history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.summary-Tuple{TransientSolverHistory}" href="#Base.summary-Tuple{TransientSolverHistory}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">summary(h::TransientSolverHistory)</code></pre><p>Return named tuple summarizing history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.details" href="#VoronoiFVM.details"><code>VoronoiFVM.details</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">details(h::NewtonSolverHistory)</code></pre><p>Return array of named tuples  with info on each iteration step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section><section><div><pre><code class="language-julia hljs">details(h::TransientSolverHistory)</code></pre><p>Return array of details of each solver step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.history" href="#VoronoiFVM.history"><code>VoronoiFVM.history</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">history(sol)</code></pre><p>Return solver history if <code>log</code> was set to true. See  see <a href="#VoronoiFVM.NewtonSolverHistory"><code>NewtonSolverHistory</code></a>, <a href="#VoronoiFVM.TransientSolverHistory"><code>TransientSolverHistory</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.history_details" href="#VoronoiFVM.history_details"><code>VoronoiFVM.history_details</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">history_details(sol)</code></pre><p>Return details of solver history from last <code>solve</code> call, if <code>log</code> was set to true. See <a href="#VoronoiFVM.details"><code>details</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.history_summary" href="#VoronoiFVM.history_summary"><code>VoronoiFVM.history_summary</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">history_summary(sol)</code></pre><p>Return summary of solver history from last <code>solve</code> call, if <code>log</code> was set to true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h3 id="Matrix-extraction"><a class="docs-heading-anchor" href="#Matrix-extraction">Matrix extraction</a><a id="Matrix-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-extraction" title="Permalink"></a></h3><p>For testing and teaching purposes, one can obtain residual and linearization at a given vector of unknowns</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.evaluate_residual_and_jacobian" href="#VoronoiFVM.evaluate_residual_and_jacobian"><code>VoronoiFVM.evaluate_residual_and_jacobian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">evaluate_residual_and_jacobian(system,u;
                               t=0.0, tstep=Inf,embed=0.0)</code></pre><p>Evaluate residual and jacobian at solution value u. Returns a solution vector containing a copy of  residual, and an ExendableSparseMatrix containing a copy of the linearization at u.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="diffeq"><a class="docs-heading-anchor" href="#diffeq">OrdinaryDiffEq.jl transient solver</a><a id="diffeq-1"></a><a class="docs-heading-anchor-permalink" href="#diffeq" title="Permalink"></a></h2><p>For transient problems, as an alternative to the <a href="#Built-in-solver">built-in implicit Euler method</a>, (stiff) ODE solvers from  <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>  can be used.</p><p>The interface just provides two methods: creation of an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> from a <a href="../system/#VoronoiFVM.System"><code>VoronoiFVM.System</code></a> and a reshape method which turns the output of the ode solver into a <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p><p>The basic usage pattern is as follows: use <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> and replace the call to the built-in solver</p><pre><code class="language-julia hljs">sol=solve(sys; times=(t0,t1), inival=inival)</code></pre><p>by</p><pre><code class="language-julia hljs">problem = ODEProblem(sys,inival,(t0,t1))
odesol = solve(problem, solver)
sol=reshape(odesol,sys)</code></pre><p>Here, <code>solver</code> is some  ODE/DAE solver from <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>. It is preferable to choose methods able to handle <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Stiff-Problems">stiff problems</a>. Moreover, often, discretized PDE systems (e.g. containing elliptic equations) are differential agebraic equation (DAE) systems  which should be solved by <a href="https://diffeq.sciml.ai/stable/solvers/dae_solve/">DAE solvers</a>. Some choices to start with are Rosenbrock methods like  <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/#Rosenbrock-W-Methods">Rosenbrock23</a> and multistep methods like <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/#Multistep-Methods">QNDF</a> and <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/#Multistep-Methods">FBDF</a>.</p><p>If the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> package is loaded, the <code>solver</code> parameter can be omitted, and some default is chosen.</p><p>The solution <code>odesol</code> returned by <code>solve</code> conforms to the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/solution/#Array-Interface">ArrayInterface</a> but &quot;forgot&quot; the VoronoiFVM species structure. Using </p><p>Accessing <code>odesol(t)</code> will return an interpolated solution vector giving the value of the solution at moment <code>t</code>. Using <a href="../system/#Base.reshape-Tuple{AbstractVector, VoronoiFVM.AbstractSystem}"><code>reshape(::AbstractVector, ::VoronoiFVM.AbstractSystem)</code></a> on <code>(odesol(t),system)</code> it can be turned into into a sparse or dense array reflecting the species structure of <code>system</code>. The order of the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/solution/#Interpolations-and-Calculating-Derivatives">interpolation</a> depends on the ODE solver.</p><p>Using <a href="#Base.reshape-Tuple{AbstractDiffEqArray, VoronoiFVM.AbstractSystem}"><code>reshape(::AbstractDiffEqArray,::VoronoiFVM.AbstractSystem)</code></a> on <code>(odesol, system)</code> returns a <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a> knowing the species structure.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ODEProblem" href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ODEProblem(state,inival,tspan,callback=SciMLBase.CallbackSet())</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> from  a system state. See <a href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem(sys::VoronoiFVM.System, inival, tspan;kwargs...)</code></a> for more documentation.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section><section><div><pre><code class="language-julia hljs">ODEProblem(system,inival,tspan,callback=SciMLBase.CallbackSet())</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> in <a href="https://diffeq.sciml.ai/stable/solvers/dae_solve/#OrdinaryDiffEq.jl-(Mass-Matrix)">mass matrix form</a> which can  be handeled by ODE solvers from <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>Parameters:</p><ul><li><code>system</code>: A <a href="https://j-fu.github.io/VoronoiFVM.jl/stable/system/#VoronoiFVM.System-Tuple{ExtendableGrid}"><code>VoronoiFVM.System</code></a></li><li><code>inival</code>: Initial value. Consider to  pass a stationary solution at <code>tspan[1]</code>.</li><li><code>tspan</code>: Time interval </li><li><code>callback</code> : (optional) <a href="https://diffeq.sciml.ai/stable/features/callback_functions/#Using-Callbacks">callback</a> for ODE solver </li></ul><p>The method returns an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> which can be solved by <a href="https://diffeq.sciml.ai/stable/basics/common_solver_opts/">solve()</a>.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.reshape-Tuple{AbstractDiffEqArray, VoronoiFVM.AbstractSystem}" href="#Base.reshape-Tuple{AbstractDiffEqArray, VoronoiFVM.AbstractSystem}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reshape(ode_solution, system; times=nothing, state=nothing)</code></pre><p>Create a <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a> from the output of the ode solver which reflects the species structure of the system ignored by the ODE solver. Howvever the interpolation behind <code>reshaped_sol(t)</code> will be linear and ignores the possibility of higher order interpolations with <code>ode_sol</code>.</p><p>If <code>times</code> is specified, the (possibly higher order) interpolated solution at the given moments of time will be returned.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SciMLBase.ODEFunction" href="#SciMLBase.ODEFunction"><code>SciMLBase.ODEFunction</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> ODEFunction(state,inival=unknowns(system,inival=0),t0=0)</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEFunction</a>. For more documentation, see <a href="#SciMLBase.ODEFunction"><code>SciMLBase.ODEFunction(state::VoronoiFVM.SystemState; kwargs...)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section><section><div><pre><code class="language-julia hljs"> ODEFunction(system,inival=unknowns(system,inival=0),t0=0)</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEFunction</a> in <a href="https://diffeq.sciml.ai/stable/solvers/dae_solve/#OrdinaryDiffEq.jl-(Mass-Matrix)">mass matrix form</a> to be handeled by ODE solvers from <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>Parameters:</p><ul><li><code>system</code>: A <a href="https://j-fu.github.io/VoronoiFVM.jl/stable/system/#VoronoiFVM.System-Tuple{ExtendableGrid}"><code>VoronoiFVM.System</code></a></li><li><code>jacval</code> (optional): Initial value. Default is a zero vector. Consider to  pass a stationary solution at time <code>tjac</code>.</li><li><code>tjac</code> (optional): tjac, Default: 0</li></ul><p>The <code>jacval</code> and <code>tjac</code> are passed  for a first evaluation of the Jacobian, allowing to detect the sparsity pattern which is passed to the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="Legacy-API"><a class="docs-heading-anchor" href="#Legacy-API">Legacy API</a><a id="Legacy-API-1"></a><a class="docs-heading-anchor-permalink" href="#Legacy-API" title="Permalink"></a></h2><p>During the development of the code, a number of API variants have been developed which  are supported for backward compatibility.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="VoronoiFVM.NewtonControl" href="#VoronoiFVM.NewtonControl"><code>VoronoiFVM.NewtonControl</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NewtonControl</code></pre><p>Legacy name of SolverControl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solutions/">« Solution objects</a><a class="docs-footer-nextpage" href="../post/">Postprocessing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 8 October 2024 22:19">Tuesday 8 October 2024</span>. Using Julia version 1.11.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
