<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · VoronoiFVM.jl</title><meta name="title" content="Solvers · VoronoiFVM.jl"/><meta property="og:title" content="Solvers · VoronoiFVM.jl"/><meta property="twitter:title" content="Solvers · VoronoiFVM.jl"/><meta name="description" content="Documentation for VoronoiFVM.jl."/><meta property="og:description" content="Documentation for VoronoiFVM.jl."/><meta property="twitter:description" content="Documentation for VoronoiFVM.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VoronoiFVM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../changes/">Changelog</a></li><li><a class="tocitem" href="../method/">The Voronoi finite volume method</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../system/">System</a></li><li><a class="tocitem" href="../physics/">Physics &amp; special functions</a></li><li><a class="tocitem" href="../solutions/">Solution objects</a></li><li class="is-active"><a class="tocitem" href>Solvers</a><ul class="internal"><li><a class="tocitem" href="#Built-in-solver"><span>Built-in solver</span></a></li><li><a class="tocitem" href="#diffeq"><span>OrdinaryDiffEq.jl transient solver</span></a></li><li><a class="tocitem" href="#Legacy-API"><span>Legacy API</span></a></li></ul></li><li><a class="tocitem" href="../post/">Postprocessing</a></li><li><a class="tocitem" href="../quantities/">Quantities</a></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../internal/">Internal API</a></li><li><a class="tocitem" href="../allindex/">Index</a></li><li><a class="tocitem" href="../extensions/"><code>ExtendableFEMBase</code> Extension</a></li><li><a class="tocitem" href="../devel/">Development hints</a></li></ul></li><li><span class="tocitem">Tutorial Notebooks</span><ul><li><a class="tocitem" href="../notebooks/">About the notebooks</a></li><li><a class="tocitem" href="../plutostatichtml_examples/ode-diffusion1d/">OrdinaryDiffEq.jl nonlinear diffusion</a></li><li><a class="tocitem" href="../plutostatichtml_examples/ode-wave1d/">OrdinaryDiffEq.jl 1D wave equation</a></li><li><a class="tocitem" href="../plutostatichtml_examples/ode-nlstorage1d/">OrdinaryDiffEq.jl changing mass matrix</a></li><li><a class="tocitem" href="../plutostatichtml_examples/heterogeneous-catalysis/">Coupling with Catalyst.jl</a></li><li><a class="tocitem" href="../plutostatichtml_examples/outflow/">Outflow boundary conditions</a></li><li><a class="tocitem" href="../plutostatichtml_examples/flux-reconstruction/">Obtaining vector fields</a></li><li><a class="tocitem" href="../plutostatichtml_examples/interfaces1d/">Internal interfaces (1D)</a></li><li><a class="tocitem" href="../plutostatichtml_examples/problemcase/">A case for caution</a></li><li><a class="tocitem" href="../plutostatichtml_examples/nonlinear-solvers/">Nonlinear solver control</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../runexamples/">About the examples</a></li><li><a class="tocitem" href="../module_examples/Example101_Laplace1D/">101: 1D Laplace equation</a></li><li><a class="tocitem" href="../module_examples/Example102_StationaryConvectionDiffusion1D/">102: 1D Stationary convection-diffusion equation</a></li><li><a class="tocitem" href="../module_examples/Example103_ConvectionDiffusion1D/">103: 1D Transient convection-diffusion equation</a></li><li><a class="tocitem" href="../module_examples/Example105_NonlinearPoisson1D/">105: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../module_examples/Example106_NonlinearDiffusion1D/">106: 1D Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../module_examples/Example107_NonlinearStorage1D/">107: 1D Nonlinear Storage</a></li><li><a class="tocitem" href="../module_examples/Example108_OrdinaryDiffEq1D/">108: 1D Nonlinear Diffusion equation with Rosenbrock method</a></li><li><a class="tocitem" href="../module_examples/Example110_ReactionDiffusion1D_TwoSpecies/">110: 1D Reaction Diffusion equation with two species</a></li><li><a class="tocitem" href="../module_examples/Example115_HeterogeneousCatalysis1D/">115: 1D heterogeneous catalysis</a></li><li><a class="tocitem" href="../module_examples/Example120_ThreeRegions1D/">120: Differing Species Sets in Three Regions, 1D</a></li><li><a class="tocitem" href="../module_examples/Example121_PoissonPointCharge1D/">121: 1D Poisson Equation with Point Charge</a></li><li><a class="tocitem" href="../module_examples/Example125_TestFunctions1D/">125: Terminal Flux Calculation via Test Functions, 1D</a></li><li><a class="tocitem" href="../module_examples/Example150_Impedance1D/">150: Impedance calculation</a></li><li><a class="tocitem" href="../module_examples/Example151_Impedance1D/">151: Impedance calculation</a></li><li><a class="tocitem" href="../module_examples/Example160_UnipolarDriftDiffusion1D/">160: Unipolar degenerate drift-diffusion</a></li><li><a class="tocitem" href="../module_examples/Example161_BipolarDriftDiffusionCurrent/">161: Bipolar drift-diffusion with different definition of current</a></li><li><a class="tocitem" href="../module_examples/Example201_Laplace2D/">201: 2D Laplace equation</a></li><li><a class="tocitem" href="../module_examples/Example203_CoordinateSystems/">203: Various coordinate systems</a></li><li><a class="tocitem" href="../module_examples/Example204_HagenPoiseuille/">204: 2D Convection in Hagen-Poiseuille flow</a></li><li><a class="tocitem" href="../module_examples/Example205_StagnationPoint/">205: Convection in axisymmetric stagnation point flow</a></li><li><a class="tocitem" href="../module_examples/Example206_JouleHeat/">206: 2D Joule heating</a></li><li><a class="tocitem" href="../module_examples/Example207_NonlinearPoisson2D/">207: 2D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../module_examples/Example210_NonlinearPoisson2D_Reaction/">210: 2D Nonlinear Poisson with reaction</a></li><li><a class="tocitem" href="../module_examples/Example215_NonlinearPoisson2D_BoundaryReaction/">215: 2D Nonlinear Poisson with boundary reaction</a></li><li><a class="tocitem" href="../module_examples/Example220_NonlinearPoisson2D_BoundarySpecies/">220: 2D Nonlinear Poisson with boundary reaction and boundary species</a></li><li><a class="tocitem" href="../module_examples/Example221_EquationBlockPrecon/">221: Equation block preconditioning</a></li><li><a class="tocitem" href="../module_examples/Example225_TestFunctions2D/">225: Terminal flux calculation via test functions, nD</a></li><li><a class="tocitem" href="../module_examples/Example226_BoundaryIntegral/">226: Terminal flux calculation via test functions, nD, boundary reaction</a></li><li><a class="tocitem" href="../module_examples/Example230_BoundaryFlux/">103: Boundary flux</a></li><li><a class="tocitem" href="../module_examples/Example240_FiniteElementVelocities/">240: 2D Convection in quadratic stagnation flow velocity field</a></li><li><a class="tocitem" href="../module_examples/Example301_Laplace3D/">301: 3D Laplace equation</a></li><li><a class="tocitem" href="../module_examples/Example311_HeatEquation_BoundaryDiffusion/">311: Heat Equation with boundary diffusion</a></li><li><a class="tocitem" href="../module_examples/Example405_GenericOperator/">405: Generic operator</a></li><li><a class="tocitem" href="../module_examples/Example406_WeirdReaction/">406: 1D Weird Surface Reaction</a></li><li><a class="tocitem" href="../module_examples/Example410_ManySpecies/">410: Many Species</a></li><li><a class="tocitem" href="../module_examples/Example420_DiscontinuousQuantities/">420: Discontinuous Quantities</a></li><li><a class="tocitem" href="../module_examples/Example421_AbstractQuantities_TestFunctions/">421: Current Calculation for AbstractQuantities</a></li><li><a class="tocitem" href="../module_examples/Example422_InterfaceQuantities/">422: Drift-Diffusion with Discontinuous and Interface Potentials</a></li><li><a class="tocitem" href="../module_examples/Example424_AbstractQuantitiesInit/">424: Initialization of Abstract quantities</a></li><li><a class="tocitem" href="../module_examples/Example430_ParameterDerivativesStationary/">430: Parameter Derivatives (stationary)</a></li><li><a class="tocitem" href="../module_examples/Example435_HigherPrecision/">434: Higher precision</a></li><li><a class="tocitem" href="../module_examples/Example440_ParallelState/">440: Parallel solves</a></li></ul></li><li><span class="tocitem">Development Examples</span><ul><li><a class="tocitem" href="../module_examples/DevEx002_EdgeReaction/">002: check edge reaction</a></li><li><a class="tocitem" href="../module_examples/DevEx003_Solvers/">003: New linear solver API</a></li><li><a class="tocitem" href="../module_examples/DevEx004_EquationBlock3D/">004: 3D Nonlinear Reaction-Diffusion System with Coupled Species</a></li><li><a class="tocitem" href="../module_examples/DevEx005_Mixture/">005: Mixture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/master/docs/src/solver.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers"><a class="docs-heading-anchor" href="#Solvers">Solvers</a><a id="Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers" title="Permalink"></a></h1><p>The package comes with a <a href="#Built-in-solver">built-in solve method</a> which solves  stationary problems, homotopy embedding problems and transient problems  via the implicit Euler method. In particular, the transient solver allows to use nonlinear storage terms.</p><p>Alternatively, <a href="#diffeq">OrdinaryDiffEq.jl based solvers</a> can be used  for transient problems.</p><h2 id="Built-in-solver"><a class="docs-heading-anchor" href="#Built-in-solver">Built-in solver</a><a id="Built-in-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-solver" title="Permalink"></a></h2><p>This solver and its default parameters are tuned for robustness, possibly at the expense of solution speed. Careful tuning of the parameters, or – in the case of transient problems – the choice of a <a href="#diffeq">OrdinaryDiffEq.jl based solver</a> can significantly improve the performance.</p><p>Overview:</p><ul><li><a href="#Solve-method">Solve method</a></li><li><a href="#Solver-control">Solver control</a></li><li><a href="#System-state">System state</a></li><li><a href="#Linear-solver-control">Linear solver control</a></li><li><a href="#History-handling">History handling</a></li><li><a href="#Matrix-extraction">Matrix extraction</a></li></ul><h3 id="Solve-method"><a class="docs-heading-anchor" href="#Solve-method">Solve method</a><a id="Solve-method-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-method" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><a class="docstring-binding" href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve(system; kwargs...)</code></pre><p>Built-in solution method for <a href="../system/#VoronoiFVM.System"><code>VoronoiFVM.System</code></a>.  </p><p>Keyword arguments:</p><ul><li><p>General for all solvers </p><ul><li><code>inival</code> (default: 0) : Array created via <a href="../post/#VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.ImpedanceSystem{Tv}}, Tuple{Tv}} where Tv"><code>unknowns</code></a> or  number giving the initial value.</li><li><code>control</code> (default: nothing): Pass instance of <a href="#VoronoiFVM.SolverControl"><code>SolverControl</code></a></li><li>All elements of <a href="#VoronoiFVM.SolverControl"><code>SolverControl</code></a> can be used as kwargs. Eventually overwrites values given via <code>control</code></li><li><code>params</code>: Parameters (Parameter handling is experimental and may change)</li></ul></li><li><p><strong>Stationary solver</strong>: Invoked if neither <code>times</code> nor <code>embed</code>, nor <code>tstep</code> are given as keyword argument.</p><ul><li><code>time</code> (default: <code>0.0</code>): Set time value.</li></ul><p>Returns a <a href="../solutions/#VoronoiFVM.DenseSolutionArray"><code>DenseSolutionArray</code></a> or <a href="../solutions/#VoronoiFVM.SparseSolutionArray"><code>SparseSolutionArray</code></a></p></li><li><p><strong>Embedding (homotopy) solver</strong>: Invoked if <code>embed</code> kwarg is given. Use homotopy embedding + damped Newton&#39;s method  to  solve a stationary problem or to solve series of parameter dependent problems. Parameter step control is performed according to solver control data.  Keyword arguments and default values are:</p><ul><li><code>embed</code> (default: <code>nothing</code> ): vector of parameter values to be reached exactly</li></ul><p>In addition,  all kwargs of the implicit Euler solver (besides <code>times</code>) are handled, including <code>handle_exceptions</code> (see below).   Step size control is performed based on the parameters <code>Δp, Δp_max, Δp_min, Δp_grow, Δp_decrease, Δu_opt, Δu_max_factor</code>. Returns a transient solution object <code>sol</code> containing the stored solution(s),  see <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p></li><li><p><strong>Implicit Euler transient solver</strong>: Invoked if <code>times</code> kwarg is given. Use implicit Euler method  + damped   Newton&#39;s method  to  solve time dependent problem. Time step control is performed according to solver control data.  kwargs and default values are:</p><ul><li><code>times</code> (default: <code>nothing</code> ): vector of time values to be reached exactly</li><li><code>pre</code> (default: <code>(sol,t)-&gt;nothing</code> ):  callback invoked before each time step</li><li><code>post</code>  (default:  <code>(sol,oldsol, t, Δt)-&gt;nothing</code> ): callback invoked after each time step</li><li><code>sample</code> (default:  <code>(sol,t)-&gt;nothing</code> ): callback invoked after timestep for all times in <code>times[2:end]</code>.</li><li><code>delta</code> (default:  <code>(system, u,v,t, Δt)-&gt;norm(sys,u-v,Inf)</code> ):  Value  used to control the time step size <code>Δu</code></li></ul><p>Step size control is performed based on the parameters <code>Δt, Δt_max, Δt_min, Δt_grow, Δt_decrease, Δu_opt, Δu_max_factor</code>. If <code>control.handle_exceptions</code> is true, if time step solution  throws an error, stepsize  is lowered, and  step solution is called again with a smaller time value. If <code>control.Δt&lt;control.Δt_min</code>, solution is aborted with error. Returns a transient solution object <code>sol</code> containing the stored solution,  see <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p></li><li><p><strong>Implicit Euler timestep solver</strong>.  Invoked if <code>tstep</code> kwarg is given. Solve one time step of the implicit Euler method.</p><ul><li><code>time</code> (default: <code>0</code>): Set time value. </li><li><code>tstep</code>: time step</li></ul><p>Returns a <a href="../solutions/#VoronoiFVM.DenseSolutionArray"><code>DenseSolutionArray</code></a> or <a href="../solutions/#VoronoiFVM.SparseSolutionArray"><code>SparseSolutionArray</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_solver.jl#L579-L624">source</a></section></details></article><h3 id="Solver-control"><a class="docs-heading-anchor" href="#Solver-control">Solver control</a><a id="Solver-control-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-control" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="VoronoiFVM.SolverControl"><a class="docstring-binding" href="#VoronoiFVM.SolverControl"><code>VoronoiFVM.SolverControl</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SolverControl
SolverControl(;kwargs...)</code></pre><p>Solver control parameter for time stepping, embedding, Newton method and linear solver control. All field names can be used as keyword arguments for <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>solve(system::VoronoiFVM.AbstractSystem; kwargs...)</code></a></p><p>Newton&#39;s method solves <span>$F(u)=0$</span> by the iterative procedure <span>$u_{i+1}=u_{i} - d_i F&#39;(u_i)^{-1}F(u_i)$</span> starting with some initial value <span>$u_0$</span>, where <span>$d_i$</span> is a damping parameter.</p><ul><li><p><code>verbose::Union{Bool, String}</code>: Verbosity control. A collection of output categories is given in a string composed of the following letters:</p><ul><li>a: allocation warnings</li><li>d: deprecation warnings</li><li>e: time/parameter evolution log</li><li>n: newton solver log</li><li>l: linear solver log</li></ul><p>Alternatively, a Bool value can be given, resulting in</p><ul><li>true: &quot;neda&quot;</li><li>false: &quot;da&quot;</li></ul><p>Switch off all output including deprecation warnings via <code>verbose=&quot;&quot;</code>. In the output, corresponding messages are marked e.g. via &#39;[n]&#39;, <code>[a]</code> etc. (besides of &#39;[l]&#39;)</p><p>For switching between printing output and logging output, see <a href="../misc/#VoronoiFVM.log_output!"><code>log_output!</code></a> and <a href="../misc/#VoronoiFVM.print_output!"><code>print_output!</code></a> .</p></li></ul><ul><li><code>abstol::Float64</code>: Tolerance (in terms of norm of Newton update): terminate if <span>$\Delta u_i=||u_{i+1}-u_i||_\infty &lt;$</span> <code>abstol</code>.</li></ul><ul><li><code>reltol::Float64</code>: Tolerance (relative to the size of the first update): terminate if <span>$\Delta u_i/\Delta u_1&lt;$</span> <code>reltol</code>.</li></ul><ul><li><code>maxiters::Int64</code>: Maximum number of newton iterations.</li></ul><ul><li><code>tol_round::Float64</code>: Tolerance for roundoff error detection: terminate if   <span>$|\;||u_{i+1}||_1 - ||u_{i}||_1\;|/ ||u_{i}||_1&lt;$</span> <code>tol_round</code> occurred <code>max_round</code> times in a row.</li></ul><ul><li><code>tol_mono::Float64</code>: Tolerance for monotonicity test: terminate with error if <span>$\Delta u_i/\Delta u_{i-1}&gt;$</span> <code>1/tol_mono</code>.</li></ul><ul><li><code>damp_initial::Float64</code>: Initial damping parameter <span>$d_0$</span>. To handle convergence problems, set this to a value less than 1.</li></ul><ul><li><code>damp_growth::Float64</code>: Damping parameter growth factor: <span>$d_{i+1}=\min(d_i\cdot$</span> <code>max_growth</code> <span>$,1)$</span>. It should be larger than 1.</li></ul><ul><li><code>max_round::Int64</code>: Maximum number of consecutive iterations within roundoff error tolerance The default effectively disables this criterion.</li></ul><ul><li><code>unorm::Function</code>: Calculation of Newton update norm</li></ul><ul><li><code>rnorm::Function</code>: Functional for roundoff error calculation</li></ul><ul><li><p><code>method_linear::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm}</code>: Solver method for linear systems (see LinearSolve.jl). If given <code>nothing</code>, as default are chosen:</p><ul><li><code>UMFPACKFactorization()</code> for sparse matrices with Float64</li><li><code>SparspakFactorization()</code> for sparse matrices with  general number types.</li><li>Defaults from LinearSolve.jl for tridiagonal and banded matrices</li></ul><p>Any sparse direct and iterative solver available via <a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#Sparse-Matrices">LinearSolve.jl</a> can be chosen.</p></li></ul><ul><li><code>reltol_linear::Float64</code>:     Relative tolerance of iterative linear solver.</li></ul><ul><li><code>abstol_linear::Float64</code>: Absolute tolerance of iterative linear solver.</li></ul><ul><li><code>maxiters_linear::Int64</code>: Maximum number of iterations of linear solver</li></ul><ul><li><code>keepcurrent_linear::Bool</code>: Update preconditioner in each Newton step ? Translates to <code>reuse_precs=!keepcurrent_linear</code> for LinearSolve.</li></ul><ul><li><code>Δp::Float64</code>: Initial parameter step for embedding.</li></ul><ul><li><code>Δp_max::Float64</code>: Maximal parameter step size.</li></ul><ul><li><code>Δp_min::Float64</code>: Minimal parameter step size.</li></ul><ul><li><code>Δp_grow::Float64</code>: Maximal parameter step size growth.</li></ul><ul><li><code>Δp_decrease::Float64</code>: Parameter step decrease factor upon rejection</li></ul><ul><li><code>Δt::Float64</code>: Initial time step  size.</li></ul><ul><li><code>Δt_max::Float64</code>: Maximal time step size.</li></ul><ul><li><code>Δt_min::Float64</code>: Minimal time step size.</li></ul><ul><li><code>Δt_grow::Float64</code>: Maximal time step size growth.</li></ul><ul><li><code>Δt_decrease::Float64</code>: Time step decrease factor upon rejection</li></ul><ul><li><code>Δu_opt::Float64</code>: Optimal size of update for time stepping and embedding. The algorithm tries to keep the difference in norm between &quot;old&quot; and &quot;new&quot; solutions  approximately at this value.</li></ul><ul><li><code>Δu_max_factor::Float64</code>: Control maximum  sice of update <code>Δu</code> for time stepping and embedding relative to <code>Δu_opt</code>. Time steps with <code>Δu &gt; Δu_max_factor*Δu_opt</code> will be rejected.</li></ul><ul><li><code>force_first_step::Bool</code>: Force first timestep.</li></ul><ul><li><code>num_final_steps::Int64</code>: Number of final steps to adjust at end of time interval in order to prevent breakdown of step size.</li></ul><ul><li><p><code>handle_exceptions::Bool</code>: Handle exceptions during transient solver and parameter embedding. If <code>true</code>, exceptions in Newton solves are caught, the embedding resp. time step is lowered, and solution is retried. Moreover, if embedding or time stepping fails (e.g. due to reaching minimal step size), a warning is issued, and a solution is returned with all steps calculated so far.</p><p>Otherwise (by default) errors are thrown.</p></li></ul><ul><li><code>store_all::Bool</code>: Store all steps of transient/embedding problem:</li></ul><ul><li><code>in_memory::Bool</code>: Store transient/embedding solution in memory</li></ul><ul><li><code>log::Any</code>:    Record history</li></ul><ul><li><code>edge_cutoff::Float64</code>: Edge parameter cutoff for rectangular triangles.</li></ul><ul><li><code>pre::Function</code>: Function <code>pre(sol,t)</code> called before time/embedding step</li></ul><ul><li><code>post::Function</code>: Function <code>post(sol,oldsol,t,Δt)</code> called after successful time/embedding step</li></ul><ul><li><code>sample::Function</code>: Function <code>sample(sol,t)</code> to be called for each <code>t in times[2:end]</code></li></ul><ul><li><code>delta::Function</code>: Time step error estimator. A function <code>Δu=delta(system,u,uold,t,Δt)</code> to calculate <code>Δu</code>.</li></ul><ul><li><p><code>tol_absolute::Union{Nothing, Float64}</code></p></li><li><p><code>tol_relative::Union{Nothing, Float64}</code></p></li><li><p><code>damp::Union{Nothing, Float64}</code></p></li><li><p><code>damp_grow::Union{Nothing, Float64}</code></p></li><li><p><code>max_iterations::Union{Nothing, Int64}</code></p></li><li><p><code>tol_linear::Union{Nothing, Float64}</code></p></li><li><p><code>max_lureuse::Union{Nothing, Int64}</code></p></li><li><p><code>mynorm::Union{Nothing, Function}</code></p></li><li><p><code>myrnorm::Union{Nothing, Function}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_solvercontrol.jl#L1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.fixed_timesteps!"><a class="docstring-binding" href="#VoronoiFVM.fixed_timesteps!"><code>VoronoiFVM.fixed_timesteps!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fixed_timesteps!(control,Δt; grow=1.0)</code></pre><p>Modify control data such that the time steps are fixed to a geometric sequence such that Δt<em>new=Δt</em>old*grow</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_solvercontrol.jl#L299-L306">source</a></section></details></article><h3 id="System-state"><a class="docs-heading-anchor" href="#System-state">System state</a><a id="System-state-1"></a><a class="docs-heading-anchor-permalink" href="#System-state" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="VoronoiFVM.SystemState"><a class="docstring-binding" href="#VoronoiFVM.SystemState"><code>VoronoiFVM.SystemState</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct SystemState{Tv, Tp, TMatrix&lt;:AbstractArray{Tv, 2}, TGenericMatrix, TSolArray&lt;:AbstractArray{Tv, 2}, TData}</code></pre><p>Structure holding state information for finite volume system.</p><p>Type parameters:</p><ul><li>Tv: element type of solution vectors and matrix</li><li>TMatrix:  matrix type</li><li>TSolArray: type of solution vector: (Matrix or SparseMatrixCSC)</li><li>TData: type of user data</li></ul><p>Type fields:</p><ul><li><code>system::VoronoiFVM.System</code>: Related finite volume system</li></ul><ul><li><code>data::Any</code>: User data</li></ul><ul><li><code>solution::AbstractMatrix</code>: Solution vector</li></ul><ul><li><code>matrix::AbstractMatrix</code>: Jacobi matrix for nonlinear problem</li></ul><ul><li><code>generic_matrix::Any</code>: Sparse matrix for generic operator handling</li></ul><ul><li><code>dudp::Vector{TSolArray} where {Tv, TSolArray&lt;:AbstractMatrix{Tv}}</code>: Parameter derivative (vector of solution arrays)</li></ul><ul><li><code>update::AbstractMatrix</code>: Vector holding Newton update</li></ul><ul><li><code>residual::AbstractMatrix</code>: Vector holding Newton residual</li></ul><ul><li><code>linear_cache::Any</code>: Linear solver cache</li></ul><ul><li><code>params::Vector</code>: Parameter vector</li></ul><ul><li><code>uhash::UInt64</code>: Hash value of latest unknowns vector the assembly was called with (used by differential equation interface)</li></ul><ul><li><code>history::Union{Nothing, VoronoiFVM.DiffEqHistory}</code>: History record for solution process (used by differential equation interface)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_state.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.SystemState-Tuple{Type, VoronoiFVM.AbstractSystem}"><a class="docstring-binding" href="#VoronoiFVM.SystemState-Tuple{Type, VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.SystemState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SystemState(Tv, system; data=system.physics.data, matrixtype=system.matrixtype)</code></pre><p>Create state information for finite volume system.</p><p>Arguments:</p><ul><li><code>Tv</code>: value type of unknowns, matrix</li><li><code>system</code>: Finite volume system</li></ul><p>Keyword arguments:</p><ul><li><code>data</code>: User data. Default: <code>data(system)</code></li><li><code>matrixtype</code>. Default: <code>system.matrixtype</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_state.jl#L86-L98">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.SystemState-Tuple{VoronoiFVM.AbstractSystem}"><a class="docstring-binding" href="#VoronoiFVM.SystemState-Tuple{VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.SystemState</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">SystemState(Tv, system; data=system.physics.data, matrixtype=system.matrixtype)</code></pre><p>Create state information for finite volume system.</p><p>Arguments:</p><ul><li><code>Tv</code>: value type of unknowns, matrix</li><li><code>system</code>: Finite volume system</li></ul><p>Keyword arguments:</p><ul><li><code>data</code>: User data. Default: <code>data(system)</code></li><li><code>matrixtype</code>. Default: <code>system.matrixtype</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_state.jl#L86-L98">source</a></section><section><div><pre><code class="language-julia hljs">SystemState(system; kwargs...)</code></pre><p>Shortcut for creating state with value type defined by <code>Tv</code> type parameter of system</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_state.jl#L160-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="CommonSolve.solve!-Tuple{VoronoiFVM.SystemState}"><a class="docstring-binding" href="#CommonSolve.solve!-Tuple{VoronoiFVM.SystemState}"><code>CommonSolve.solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve!(state; kwargs...)</code></pre><p>Built-in solution method for <a href="../system/#VoronoiFVM.System"><code>VoronoiFVM.System</code></a>.  </p><p>Solves finite volume system the satate is belonging to. Mutates the state and returns the solution.</p><p>For the keyword argumentsm see <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>VoronoiFVM.solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_solver.jl#L502-L511">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.similar-Tuple{VoronoiFVM.SystemState}"><a class="docstring-binding" href="#Base.similar-Tuple{VoronoiFVM.SystemState}"><code>Base.similar</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">similar(state; data=state.data)</code></pre><p>Create a new state of with the same system, different work arrays, and possibly different data. The matrix of the new state initially shares the sparsity structure with <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_state.jl#L167-L172">source</a></section></details></article><h3 id="Linear-solver-control"><a class="docs-heading-anchor" href="#Linear-solver-control">Linear solver control</a><a id="Linear-solver-control-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-solver-control" title="Permalink"></a></h3><p>Linear systems are solved using LinearSolve.jl.  Linear solve compatible solver strategies (factorizations, iterative solvers) can be specified wia  <code>method_linear</code> keyword argument to LinearSolve (equivalent to the <code>method_linear</code>  entry of <a href="#VoronoiFVM.SolverControl"><code>SolverControl</code></a>.</p><p>Currently supported possibilities are documented in the <a href="https://wias-pdelib.github.io/ExtendableSparse.jl/stable/linearsolve/#Solving-with-LinearSolve.jl">documentation of ExtendableSparse.jl</a>.</p><p>VoronoiFVM.jl provides partitioning methods for block preconditioners.</p><article><details class="docstring" open="true"><summary id="VoronoiFVM.Equationwise"><a class="docstring-binding" href="#VoronoiFVM.Equationwise"><code>VoronoiFVM.Equationwise</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct Equationwise</code></pre><p>Equationwise partitioning mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_system.jl#L1110-L1114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.partitioning"><a class="docstring-binding" href="#VoronoiFVM.partitioning"><code>VoronoiFVM.partitioning</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">partitioning(system, mode)</code></pre><p>Calculate partitioning of system unknowns to be used in block preconditioners. Possible modes:</p><ul><li><a href="#VoronoiFVM.Equationwise"><code>Equationwise</code></a>()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_system.jl#L1117-L1123">source</a></section></details></article><h3 id="History-handling"><a class="docs-heading-anchor" href="#History-handling">History handling</a><a id="History-handling-1"></a><a class="docs-heading-anchor-permalink" href="#History-handling" title="Permalink"></a></h3><p>If <code>log</code> is set to true in <code>solve</code>, the history of newton iterations and  time/embedding steps is recorded and returned as <code>history(solution)</code></p><article><details class="docstring" open="true"><summary id="VoronoiFVM.NewtonSolverHistory"><a class="docstring-binding" href="#VoronoiFVM.NewtonSolverHistory"><code>VoronoiFVM.NewtonSolverHistory</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct NewtonSolverHistory &lt;: AbstractVector{Float64}</code></pre><p>History information for one Newton solve of a nonlinear system. As an abstract vector it provides the history of the update norms. See <a href="#Base.summary-Tuple{NewtonSolverHistory}"><code>summary</code></a> and <a href="#VoronoiFVM.details"><code>details</code></a> for other ways to extract information.</p><ul><li><p><code>nlu::Int64</code>:  number of Jacobi matrix factorizations</p></li><li><p><code>nlin::Int64</code>:  number of linear iteration steps / factorization solves</p></li><li><p><code>time::Float64</code>:  Elapsed time for solution</p></li><li><p><code>tasm::Float64</code>:  Elapsed time for assembly</p></li><li><p><code>tlinsolve::Float64</code>:  Elapsed time for linear solve</p></li><li><p><code>updatenorm::Any</code>:  History of norms of <span>$||u_{i+1}-u_i||$</span></p></li><li><p><code>l1normdiff::Any</code>:  History of norms of <span>$|\;||u_{i+1}||_1 - ||u_{i}||_1\;|/ ||u_{i}||_1$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.TransientSolverHistory"><a class="docstring-binding" href="#VoronoiFVM.TransientSolverHistory"><code>VoronoiFVM.TransientSolverHistory</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct TransientSolverHistory &lt;: AbstractVector{NewtonSolverHistory}</code></pre><p>History information for transient solution/parameter embedding</p><p>As an abstract vector it provides the histories of each implicit Euler/embedding step. See <a href="#Base.summary-Tuple{NewtonSolverHistory}"><code>summary</code></a> and <a href="#VoronoiFVM.details"><code>details</code></a> for other ways to extract information.</p><ul><li><p><code>histories::Any</code>:  Histories of each implicit Euler Newton iteration</p></li><li><p><code>times::Any</code>:  Time values</p></li><li><p><code>updates::Any</code>:  Update norms used for step control</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L76-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.DiffEqHistory"><a class="docstring-binding" href="#VoronoiFVM.DiffEqHistory"><code>VoronoiFVM.DiffEqHistory</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">mutable struct DiffEqHistory</code></pre><p>History information for DiffEqHistory</p><ul><li><p><code>nd::Any</code>:  number of combined jacobi/rhs evaluations</p></li><li><p><code>njac::Any</code>:  number of combined jacobi evaluations</p></li><li><p><code>nf::Any</code>:  number of rhs evaluations</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L144-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.summary-Tuple{NewtonSolverHistory}"><a class="docstring-binding" href="#Base.summary-Tuple{NewtonSolverHistory}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summary(h::NewtonSolverHistory)</code></pre><p>Return named tuple summarizing history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L36-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.summary-Tuple{TransientSolverHistory}"><a class="docstring-binding" href="#Base.summary-Tuple{TransientSolverHistory}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">summary(h::TransientSolverHistory)</code></pre><p>Return named tuple summarizing history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L102-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.details"><a class="docstring-binding" href="#VoronoiFVM.details"><code>VoronoiFVM.details</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">details(h::NewtonSolverHistory)</code></pre><p>Return array of named tuples  with info on each iteration step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L55-L59">source</a></section><section><div><pre><code class="language-julia hljs">details(h::TransientSolverHistory)</code></pre><p>Return array of details of each solver step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.history"><a class="docstring-binding" href="#VoronoiFVM.history"><code>VoronoiFVM.history</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">history(sol)</code></pre><p>Return solver history if <code>log</code> was set to true. See  see <a href="#VoronoiFVM.NewtonSolverHistory"><code>NewtonSolverHistory</code></a>, <a href="#VoronoiFVM.TransientSolverHistory"><code>TransientSolverHistory</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L162-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.history_details"><a class="docstring-binding" href="#VoronoiFVM.history_details"><code>VoronoiFVM.history_details</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">history_details(sol)</code></pre><p>Return details of solver history from last <code>solve</code> call, if <code>log</code> was set to true. See <a href="#VoronoiFVM.details"><code>details</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L170-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="VoronoiFVM.history_summary"><a class="docstring-binding" href="#VoronoiFVM.history_summary"><code>VoronoiFVM.history_summary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">history_summary(sol)</code></pre><p>Return summary of solver history from last <code>solve</code> call, if <code>log</code> was set to true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_history.jl#L178-L182">source</a></section></details></article><h3 id="Matrix-extraction"><a class="docs-heading-anchor" href="#Matrix-extraction">Matrix extraction</a><a id="Matrix-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-extraction" title="Permalink"></a></h3><p>For testing and teaching purposes, one can obtain residual and linearization at a given vector of unknowns</p><article><details class="docstring" open="true"><summary id="VoronoiFVM.evaluate_residual_and_jacobian"><a class="docstring-binding" href="#VoronoiFVM.evaluate_residual_and_jacobian"><code>VoronoiFVM.evaluate_residual_and_jacobian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">evaluate_residual_and_jacobian(system,u;
                               t=0.0, tstep=Inf, embed=0.0, init_dirichlet=false)</code></pre><p>Evaluate residual and jacobian at solution value u. Returns a solution vector containing a copy of  residual, and an ExendableSparseMatrix containing a copy of the linearization at u. The flag <code>init_dirichlet</code> controls whether u should be adjusted to satisfy the Dirichlet boundary conditions specified by the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_solver.jl#L219-L228">source</a></section></details></article><h2 id="diffeq"><a class="docs-heading-anchor" href="#diffeq">OrdinaryDiffEq.jl transient solver</a><a id="diffeq-1"></a><a class="docs-heading-anchor-permalink" href="#diffeq" title="Permalink"></a></h2><p>For transient problems, as an alternative to the <a href="#Built-in-solver">built-in implicit Euler method</a>, (stiff) ODE solvers from  <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>  can be used.</p><p>The interface just provides two methods: creation of an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> from a <a href="../system/#VoronoiFVM.System"><code>VoronoiFVM.System</code></a> and a reshape method which turns the output of the ode solver into a <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p><p>The basic usage pattern is as follows: use <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> and replace the call to the built-in solver</p><pre><code class="language-julia hljs">sol=solve(sys; times=(t0,t1), inival=inival)</code></pre><p>by</p><pre><code class="language-julia hljs">problem = ODEProblem(sys,inival,(t0,t1))
odesol = solve(problem, solver)
sol=reshape(odesol,sys)</code></pre><p>Here, <code>solver</code> is some  ODE/DAE solver from <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a>. It is preferable to choose methods able to handle <a href="https://diffeq.sciml.ai/stable/solvers/ode_solve/#Stiff-Problems">stiff problems</a>. Moreover, often, discretized PDE systems (e.g. containing elliptic equations) are differential agebraic equation (DAE) systems  which should be solved by <a href="https://diffeq.sciml.ai/stable/solvers/dae_solve/">DAE solvers</a>. Some choices to start with are Rosenbrock methods like  <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/#Rosenbrock-W-Methods">Rosenbrock23</a> and multistep methods like <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/#Multistep-Methods">QNDF</a> and <a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/#Multistep-Methods">FBDF</a>.</p><p>If the <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> package is loaded, the <code>solver</code> parameter can be omitted, and some default is chosen.</p><p>The solution <code>odesol</code> returned by <code>solve</code> conforms to the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/solution/#Array-Interface">ArrayInterface</a> but &quot;forgot&quot; the VoronoiFVM species structure. Using </p><p>Accessing <code>odesol(t)</code> will return an interpolated solution vector giving the value of the solution at moment <code>t</code>. Using <a href="../system/#Base.reshape-Tuple{AbstractVector, VoronoiFVM.AbstractSystem}"><code>reshape(::AbstractVector, ::VoronoiFVM.AbstractSystem)</code></a> on <code>(odesol(t),system)</code> it can be turned into into a sparse or dense array reflecting the species structure of <code>system</code>. The order of the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/solution/#Interpolations-and-Calculating-Derivatives">interpolation</a> depends on the ODE solver.</p><p>Using <a href="#Base.reshape-Tuple{AbstractDiffEqArray, VoronoiFVM.AbstractSystem}"><code>reshape(::AbstractDiffEqArray,::VoronoiFVM.AbstractSystem)</code></a> on <code>(odesol, system)</code> returns a <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a> knowing the species structure.</p><article><details class="docstring" open="true"><summary id="SciMLBase.ODEProblem"><a class="docstring-binding" href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ODEProblem(state,inival,tspan,callback=SciMLBase.CallbackSet())</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> from  a system state. See <a href="#SciMLBase.ODEProblem"><code>SciMLBase.ODEProblem(sys::VoronoiFVM.System, inival, tspan;kwargs...)</code></a> for more documentation.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_diffeq_interface.jl#L159-L167">source</a></section><section><div><pre><code class="language-julia hljs">ODEProblem(system,inival,tspan,callback=SciMLBase.CallbackSet())</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> in <a href="https://diffeq.sciml.ai/stable/solvers/dae_solve/#OrdinaryDiffEq.jl-(Mass-Matrix)">mass matrix form</a> which can  be handled by ODE solvers from <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>Parameters:</p><ul><li><code>system</code>: A <a href="https://WIAS-PDELib.github.io/VoronoiFVM.jl/stable/system/#VoronoiFVM.System-Tuple{ExtendableGrid}"><code>VoronoiFVM.System</code></a></li><li><code>inival</code>: Initial value. Consider to  pass a stationary solution at <code>tspan[1]</code>.</li><li><code>tspan</code>: Time interval </li><li><code>callback</code> : (optional) <a href="https://diffeq.sciml.ai/stable/features/callback_functions/#Using-Callbacks">callback</a> for ODE solver </li></ul><p>The method returns an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEProblem</a> which can be solved by <a href="https://diffeq.sciml.ai/stable/basics/common_solver_opts/">solve()</a>.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_diffeq_interface.jl#L177-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.reshape-Tuple{AbstractDiffEqArray, VoronoiFVM.AbstractSystem}"><a class="docstring-binding" href="#Base.reshape-Tuple{AbstractDiffEqArray, VoronoiFVM.AbstractSystem}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reshape(ode_solution, system; times=nothing, state=nothing)</code></pre><p>Create a <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a> from the output of the ode solver which reflects the species structure of the system ignored by the ODE solver. Howvever the interpolation behind <code>reshaped_sol(t)</code> will be linear and ignores the possibility of higher order interpolations with <code>ode_sol</code>.</p><p>If <code>times</code> is specified, the (possibly higher order) interpolated solution at the given moments of time will be returned.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_diffeq_interface.jl#L202-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SciMLBase.ODEFunction"><a class="docstring-binding" href="#SciMLBase.ODEFunction"><code>SciMLBase.ODEFunction</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs"> ODEFunction(state; jacval = unknowns(sys, 0), tjac = 0 )</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEFunction</a>. For more documentation, see <a href="#SciMLBase.ODEFunction"><code>SciMLBase.ODEFunction(state::VoronoiFVM.SystemState; kwargs...)</code></a> <code>jacval</code> and <code>tjac</code> are passed to <a href="../internal/#VoronoiFVM.prepare_diffeq!"><code>prepare_diffeq!</code></a> and used there to calculate the Jacobian prototype.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_diffeq_interface.jl#L122-L130">source</a></section><section><div><pre><code class="language-julia hljs"> ODEFunction(system; jacval=unknowns(system,inival=0),tjac=0)</code></pre><p>Create an <a href="https://diffeq.sciml.ai/stable/basics/overview/#Defining-Problems">ODEFunction</a> in <a href="https://diffeq.sciml.ai/stable/solvers/dae_solve/#OrdinaryDiffEq.jl-(Mass-Matrix)">mass matrix form</a> to be handled by ODE solvers from <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>Parameters:</p><ul><li><code>system</code>: A <a href="https://WIAS-PDELib.github.io/VoronoiFVM.jl/stable/system/#VoronoiFVM.System-Tuple{ExtendableGrid}"><code>VoronoiFVM.System</code></a></li><li><code>jacval</code> (optional): Initial value. Default is a zero vector. Consider to  pass a stationary solution at time <code>tjac</code>.</li><li><code>tjac</code> (optional): tjac, Default: 0</li></ul><p>The <code>jacval</code> and <code>tjac</code> are passed  for a first evaluation of the Jacobian, allowing to detect the sparsity pattern which is passed to the solver.</p><p>Defined in VoronoiFVM.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_diffeq_interface.jl#L140-L156">source</a></section></details></article><h2 id="Legacy-API"><a class="docs-heading-anchor" href="#Legacy-API">Legacy API</a><a id="Legacy-API-1"></a><a class="docs-heading-anchor-permalink" href="#Legacy-API" title="Permalink"></a></h2><p>During the development of the code, a number of API variants have been developed which  are supported for backward compatibility.</p><article><details class="docstring" open="true"><summary id="VoronoiFVM.NewtonControl"><a class="docstring-binding" href="#VoronoiFVM.NewtonControl"><code>VoronoiFVM.NewtonControl</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NewtonControl</code></pre><p>Legacy name of SolverControl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/7ad71483941f127610f01e5adc2991e61cd126be/src/vfvm_solvercontrol.jl#L322-L326">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solutions/">« Solution objects</a><a class="docs-footer-nextpage" href="../post/">Postprocessing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 15 January 2026 22:56">Thursday 15 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
