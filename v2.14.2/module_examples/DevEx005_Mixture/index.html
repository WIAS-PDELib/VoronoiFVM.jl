<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>005: Mixture · VoronoiFVM.jl</title><meta name="title" content="005: Mixture · VoronoiFVM.jl"/><meta property="og:title" content="005: Mixture · VoronoiFVM.jl"/><meta property="twitter:title" content="005: Mixture · VoronoiFVM.jl"/><meta name="description" content="Documentation for VoronoiFVM.jl."/><meta property="og:description" content="Documentation for VoronoiFVM.jl."/><meta property="twitter:description" content="Documentation for VoronoiFVM.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">VoronoiFVM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../changes/">Changelog</a></li><li><a class="tocitem" href="../../method/">The Voronoi finite volume method</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../../system/">System</a></li><li><a class="tocitem" href="../../physics/">Physics &amp; special functions</a></li><li><a class="tocitem" href="../../solutions/">Solution objects</a></li><li><a class="tocitem" href="../../solver/">Solvers</a></li><li><a class="tocitem" href="../../post/">Postprocessing</a></li><li><a class="tocitem" href="../../quantities/">Quantities</a></li><li><a class="tocitem" href="../../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../../internal/">Internal API</a></li><li><a class="tocitem" href="../../allindex/">Index</a></li><li><a class="tocitem" href="../../extensions/"><code>ExtendableFEMBase</code> Extension</a></li><li><a class="tocitem" href="../../devel/">Development hints</a></li></ul></li><li><span class="tocitem">Tutorial Notebooks</span><ul><li><a class="tocitem" href="../../notebooks/">About the notebooks</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/ode-diffusion1d/">OrdinaryDiffEq.jl nonlinear diffusion</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/ode-wave1d/">OrdinaryDiffEq.jl 1D wave equation</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/ode-nlstorage1d/">OrdinaryDiffEq.jl changing mass matrix</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/ode-brusselator/">OrdinaryDiffEq.jl brusselator</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/heterogeneous-catalysis/">Coupling with Catalyst.jl</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/outflow/">Outflow boundary conditions</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/flux-reconstruction/">Obtaining vector fields</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/interfaces1d/">Internal interfaces (1D)</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/problemcase/">A case for caution</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/nonlinear-solvers/">Nonlinear solver control</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/bernoulli/">Bernoulli function test</a></li><li><a class="tocitem" href="../../plutostatichtml_examples/api-update/">API Updates</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../runexamples/">About the examples</a></li><li><a class="tocitem" href="../Example101_Laplace1D/">101: 1D Laplace equation</a></li><li><a class="tocitem" href="../Example102_StationaryConvectionDiffusion1D/">102: 1D Stationary convection-diffusion equation</a></li><li><a class="tocitem" href="../Example103_ConvectionDiffusion1D/">103: 1D Transient convection-diffusion equation</a></li><li><a class="tocitem" href="../Example105_NonlinearPoisson1D/">105: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../Example106_NonlinearDiffusion1D/">106: 1D Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../Example107_NonlinearStorage1D/">107: 1D Nonlinear Storage</a></li><li><a class="tocitem" href="../Example108_OrdinaryDiffEq1D/">108: 1D Nonlinear Diffusion equation with Rosenbrock method</a></li><li><a class="tocitem" href="../Example110_ReactionDiffusion1D_TwoSpecies/">110: 1D Reaction Diffusion equation with two species</a></li><li><a class="tocitem" href="../Example115_HeterogeneousCatalysis1D/">115: 1D heterogeneous catalysis</a></li><li><a class="tocitem" href="../Example120_ThreeRegions1D/">120: Differing Species Sets in Three Regions, 1D</a></li><li><a class="tocitem" href="../Example121_PoissonPointCharge1D/">121: 1D Poisson Equation with Point Charge</a></li><li><a class="tocitem" href="../Example125_TestFunctions1D/">125: Terminal Flux Calculation via Test Functions, 1D</a></li><li><a class="tocitem" href="../Example150_Impedance1D/">150: Impedance calculation</a></li><li><a class="tocitem" href="../Example151_Impedance1D/">151: Impedance calculation</a></li><li><a class="tocitem" href="../Example160_UnipolarDriftDiffusion1D/">160: Unipolar degenerate drift-diffusion</a></li><li><a class="tocitem" href="../Example161_BipolarDriftDiffusionCurrent/">161: Bipolar drift-diffusion with different definition of current</a></li><li><a class="tocitem" href="../Example201_Laplace2D/">201: 2D Laplace equation</a></li><li><a class="tocitem" href="../Example203_CoordinateSystems/">203: Various coordinate systems</a></li><li><a class="tocitem" href="../Example204_HagenPoiseuille/">204: 2D Convection in Hagen-Poiseuille flow</a></li><li><a class="tocitem" href="../Example205_StagnationPoint/">205: Convection in axisymmetric stagnation point flow</a></li><li><a class="tocitem" href="../Example206_JouleHeat/">206: 2D Joule heating</a></li><li><a class="tocitem" href="../Example207_NonlinearPoisson2D/">207: 2D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../Example210_NonlinearPoisson2D_Reaction/">210: 2D Nonlinear Poisson with reaction</a></li><li><a class="tocitem" href="../Example215_NonlinearPoisson2D_BoundaryReaction/">215: 2D Nonlinear Poisson with boundary reaction</a></li><li><a class="tocitem" href="../Example220_NonlinearPoisson2D_BoundarySpecies/">220: 2D Nonlinear Poisson with boundary reaction and boundary species</a></li><li><a class="tocitem" href="../Example221_EquationBlockPrecon/">221: Equation block preconditioning</a></li><li><a class="tocitem" href="../Example225_TestFunctions2D/">225: Terminal flux calculation via test functions, nD</a></li><li><a class="tocitem" href="../Example226_BoundaryIntegral/">226: Terminal flux calculation via test functions, nD, boundary reaction</a></li><li><a class="tocitem" href="../Example230_BoundaryFlux/">103: Boundary flux</a></li><li><a class="tocitem" href="../Example301_Laplace3D/">301: 3D Laplace equation</a></li><li><a class="tocitem" href="../Example311_HeatEquation_BoundaryDiffusion/">311: Heat Equation with boundary diffusion</a></li><li><a class="tocitem" href="../Example405_GenericOperator/">405: Generic operator</a></li><li><a class="tocitem" href="../Example406_WeirdReaction/">406: 1D Weird Surface Reaction</a></li><li><a class="tocitem" href="../Example410_ManySpecies/">410: Many Species</a></li><li><a class="tocitem" href="../Example420_DiscontinuousQuantities/">420: Discontinuous Quantities</a></li><li><a class="tocitem" href="../Example421_AbstractQuantities_TestFunctions/">421: Current Calculation for AbstractQuantities</a></li><li><a class="tocitem" href="../Example422_InterfaceQuantities/">422: Drift-Diffusion with Discontinuous and Interface Potentials</a></li><li><a class="tocitem" href="../Example424_AbstractQuantitiesInit/">424: Initialization of Abstract quantities</a></li><li><a class="tocitem" href="../Example430_ParameterDerivativesStationary/">430: Parameter Derivatives (stationary)</a></li><li><a class="tocitem" href="../Example435_HigherPrecision/">434: Higher precision</a></li><li><a class="tocitem" href="../Example440_ParallelState/">440: Parallel solves</a></li></ul></li><li><span class="tocitem">Development Examples</span><ul><li><a class="tocitem" href="../DevEx001_Solvers/">001: Legacy API for linear solvers</a></li><li><a class="tocitem" href="../DevEx002_EdgeReaction/">002: check edge reaction</a></li><li><a class="tocitem" href="../DevEx003_Solvers/">003: New linear solver API</a></li><li><a class="tocitem" href="../DevEx004_EquationBlock3D/">004: 3D Nonlinear Reaction-Diffusion System with Coupled Species</a></li><li class="is-active"><a class="tocitem" href>005: Mixture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Development Examples</a></li><li class="is-active"><a href>005: Mixture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>005: Mixture</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/VoronoiFVM.jl/blob/master/docs/src/module_examples/DevEx005_Mixture.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="005:-Mixture"><a class="docs-heading-anchor" href="#005:-Mixture">005: Mixture</a><a id="005:-Mixture-1"></a><a class="docs-heading-anchor-permalink" href="#005:-Mixture" title="Permalink"></a></h1><p>(<a href="../DevEx005_Mixture.jl">source code</a>)</p><p>Test mixture diffusion flux. The problem is here that in the flux function we need to solve a linear system of equations which calculates the fluxes from the gradients.</p><p><span>$u_i$</span> are the species partial pressures, <span>$\vec N_i$</span> are the species fluxes. <span>$D_i^K$</span> are the Knudsen diffusion coefficients, and <span>$D^B_{ij}$</span> are the binary diffusion coefficients.</p><p class="math-container">\[  -\nabla \cdot \vec N_i =0 \quad (i=1\dots n)\\
  \frac{\vec N_i}{D^K_i} + \sum_{j\neq i}\frac{u_j \vec N_i - u_i \vec N_j}{D^B_{ij}} = -\vec \nabla u_i \quad (i=1\dots n)\]</p><p>From this representation, we can derive the matrix <span>$M=(m_{ij})$</span> with</p><p class="math-container">\[m_{ii}= \frac{1}{D^K_i} + \sum_{j\neq i} \frac{u_j}{D_ij}\\
m_{ij}= -\sum_{j\neq i} \frac{u_i}{D_ij}\]</p><p>such that</p><p class="math-container">\[	M\begin{pmatrix}
\vec N_1\\
\vdots\\
\vec N_n
\end{pmatrix}
=
\begin{pmatrix}
\vec \nabla u_1\\
\vdots\\
\vec \nabla u_n
\end{pmatrix}\]</p><p>In the two point flux finite volume discretization, this results into a corresponding linear system which calculates the discrete edge fluxes from the discrete gradients.  Here we demonstrate how to implement this in a fast, (heap) allocation free way.</p><p>For this purpose, intermediate arrays have to be used. They need to have the same element type as the unknowns passed to the flux function (which could be Float64 or some dual number).</p><p>To do so without (heap) allocations can be achieved at least in three ways tested in this example:</p><ul><li>Stack allocation within the flux function using <a href="https://github.com/JuliaSIMD/StrideArrays.jl"><code>StrideArrays</code></a><code>.StrideArray</code>, with the need to have static (compile time) information about the size of the local arrays to be allocated via e.g. a global constant, or, as demonstrated here, a type parameter. As <a href="https://juliasimd.github.io/StrideArrays.jl/stable/stack_allocation/">documented in  StrideArrays.jl</a>, use <code>@gc_preserve</code> when passing a <code>StrideArray</code> as a function parameter. See also <a href="https://discourse.julialang.org/t/what-is-stridearrays-jl/97146">this Discourse thread</a>.</li><li>Stack allocation within the flux function using <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays</code></a><code>.MArray</code>, with the need to have static (compile time) information about the size of the local arrays to be allocated via e.g. a global constant, or, as demonstrated here, a type parameter. However, this may run into  <a href="https://github.com/JuliaArrays/StaticArrays.jl/issues/874">this issue</a>, requiring <code>@inbounds</code> e.g. with reverse order loops.</li><li>Preallocation using <a href="https://github.com/SciML/PreallocationTools.jl"><code>PreallocationTools</code></a><code>.DiffCache</code>. While this avoids the need to pass the size via a compile time constant, one has to ensure that each running thread has its own cache. Here this is achieved by providing a cache for each partition.</li></ul><pre><code class="language-julia hljs">module DevEx005_Mixture

using Printf
using VoronoiFVM

using ExtendableGrids
using GridVisualize
using LinearAlgebra
using AMGCLWrap
using Random
using StrideArraysCore: @gc_preserve, StrideArray, StaticInt, PtrArray
using LinearSolve, ExtendableSparse
using ExtendableSparse: ILUZeroPreconBuilder
using StaticArrays
using ExtendableSparse
using PreallocationTools
using Metis

# Userdata structure for passing number of species as parameter known at compile time.
# Buffers are stack allocated
Base.@kwdef struct MyDataStaticSizeInfo{NSpec}
    DBinary::Symmetric{Float64, Matrix{Float64}} = Symmetric(fill(0.1, NSpec, NSpec))
    DKnudsen::Vector{Float64} = ones(NSpec)
    diribc::Vector{Int} = [1, 2]
end
nspec(::MyDataStaticSizeInfo{NSpec}) where {NSpec} = NSpec
MyDataStaticSizeInfo(nspec; kwargs...) = MyDataStaticSizeInfo{nspec}(; kwargs...)

# Flux with stack allocated buffers using StrideArray
function flux_strided(f, u, edge, data)
    T = eltype(u)
    M = StrideArray{T}(undef, StaticInt(nspec(data)), StaticInt(nspec(data)))
    au = StrideArray{T}(undef, StaticInt(nspec(data)))
    du = StrideArray{T}(undef, StaticInt(nspec(data)))
    ipiv = StrideArray{Int}(undef, StaticInt(nspec(data)))

    for ispec in 1:nspec(data)
        M[ispec, ispec] = 1.0 / data.DKnudsen[ispec]
        du[ispec] = u[ispec, 1] - u[ispec, 2]
        au[ispec] = 0.5 * (u[ispec, 1] + u[ispec, 2])
    end

    for ispec in 1:nspec(data)
        for jspec in 1:nspec(data)
            if ispec != jspec
                M[ispec, ispec] += au[jspec] / data.DBinary[ispec, jspec]
                M[ispec, jspec] = -au[ispec] / data.DBinary[ispec, jspec]
            end
        end
    end

    # Pivoting linear system solution via RecursiveFactorizations.jl (see vfvm_functions.jl)
    inplace_linsolve!(M, du, ipiv)

    for ispec in 1:nspec(data)
        f[ispec] = du[ispec]
    end
    return
end

# Flux with stack allocated buffers using MArray
function flux_marray(f, u, edge, data)
    T = eltype(u)
    n = nspec(data)

    M = MMatrix{nspec(data), nspec(data), T}(undef)
    au = MVector{nspec(data), T}(undef)
    du = MVector{nspec(data), T}(undef)
    ipiv = MVector{nspec(data), Int}(undef)

    for ispec in 1:nspec(data)
        M[ispec, ispec] = 1.0 / data.DKnudsen[ispec]
        du[ispec] = u[ispec, 1] - u[ispec, 2]
        au[ispec] = 0.5 * (u[ispec, 1] + u[ispec, 2])
    end

    for ispec in 1:nspec(data)
        for jspec in 1:nspec(data)
            if ispec != jspec
                M[ispec, ispec] += au[jspec] / data.DBinary[ispec, jspec]
                M[ispec, jspec] = -au[ispec] / data.DBinary[ispec, jspec]
            end
        end
    end

    # Pivoting linear system solution via RecursiveFactorizations.jl (see vfvm_functions.jl)
    inplace_linsolve!(M, du, ipiv)

    for ispec in 1:nspec(data)
        f[ispec] = du[ispec]
    end
    return nothing
end

# Userdata structure for passing number of species as  a field in the structure, with
# multithreading-aware pre-allocated buffers
Base.@kwdef struct MyDataPrealloc
    nspec::Int = 5
    npart::Int = 1
    DBinary::Symmetric{Float64, Matrix{Float64}} = Symmetric(fill(0.1, nspec, nspec))
    DKnudsen::Vector{Float64} = ones(nspec)
    diribc::Vector{Int} = [1, 2]
    M::Vector{DiffCache{Matrix{Float64}, Vector{Float64}}} = [DiffCache(ones(nspec, nspec), 2 * nspec) for i in 1:npart]
    au::Vector{DiffCache{Vector{Float64}, Vector{Float64}}} = [DiffCache(ones(nspec), 2 * nspec) for i in 1:npart]
    du::Vector{DiffCache{Vector{Float64}, Vector{Float64}}} = [DiffCache(ones(nspec), 2 * nspec) for i in 1:npart]
    ipiv::Vector{Vector{Int}} = [zeros(Int, nspec) for i in 1:npart]
end
nspec(data::MyDataPrealloc) = data.nspec


# Flux using pre-allocated buffers
function flux_diffcache(f, u, edge, data)
    T = eltype(u)
    n = data.nspec
    ipart = partition(edge)
    M = get_tmp(data.M[ipart], u)
    au = get_tmp(data.au[ipart], u)
    du = get_tmp(data.du[ipart], M)
    ipiv = data.ipiv[ipart]

    for ispec in 1:nspec(data)
        M[ispec, ispec] = 1.0 / data.DKnudsen[ispec]
        du[ispec] = u[ispec, 1] - u[ispec, 2]
        au[ispec] = 0.5 * (u[ispec, 1] + u[ispec, 2])
    end
    for ispec in 1:nspec(data)
        for jspec in 1:nspec(data)
            if ispec != jspec
                M[ispec, ispec] += au[jspec] / data.DBinary[ispec, jspec]
                M[ispec, jspec] = -au[ispec] / data.DBinary[ispec, jspec]
            end
        end
    end

    # Pivoting linear system solution via RecursiveFactorizations.jl (see vfvm_functions.jl)
    inplace_linsolve!(M, du, ipiv)

    for ispec in 1:nspec(data)
        f[ispec] = du[ispec]
    end

    return nothing
end


function bcondition(f, u, node, data)
    for species in 1:nspec(data)
        boundary_dirichlet!(
            f, u, node; species, region = data.diribc[1],
            value = species % 2
        )
        boundary_dirichlet!(
            f, u, node; species, region = data.diribc[2],
            value = 1 - species % 2
        )
    end
    return nothing
end

function main(;
        n = 11, nspec = 5,
        dim = 2,
        Plotter = nothing,
        verbose = &quot;&quot;,
        unknown_storage = :dense,
        flux = :flux_strided,
        strategy = nothing,
        assembly = :cellwise,
        npart = 1
    )
    h = 1.0 / convert(Float64, n - 1)
    X = collect(0.0:h:1.0)
    DBinary = Symmetric(fill(0.1, nspec, nspec))
    for ispec in 1:nspec
        DBinary[ispec, ispec] = 0
    end

    DKnudsen = fill(1.0, nspec)

    if dim == 1
        grid = simplexgrid(X)
        diribc = [1, 2]
    elseif dim == 2
        grid = simplexgrid(X, X)
        diribc = [4, 2]
    else
        grid = simplexgrid(X, X, X)
        diribc = [4, 2]
    end

    if npart &gt; 1
        grid = partition(grid, PlainMetisPartitioning(; npart), nodes = true, edges = true)
    end

    function storage(f, u, node, data)
        f .= u
        return nothing
    end

    if flux == :flux_strided
        _flux = flux_strided
        data = MyDataStaticSizeInfo(nspec; DBinary, DKnudsen, diribc)
    elseif flux == :flux_diffcache
        _flux = flux_diffcache
        data = MyDataPrealloc(; nspec, npart = num_partitions(grid), DBinary, DKnudsen, diribc)
    else
        _flux = flux_marray
        data = MyDataStaticSizeInfo(nspec; DBinary, DKnudsen, diribc)
    end

    sys = VoronoiFVM.System(grid; flux = _flux, storage, bcondition, species = 1:nspec, data, assembly, unknown_storage)

    if !isnothing(strategy) &amp;&amp; hasproperty(strategy, :precs)
        if isa(strategy.precs, BlockPreconBuilder)
            strategy.precs.partitioning = A -&gt; partitioning(sys, Equationwise())
        end
        if isa(strategy.precs, ILUZeroPreconBuilder) &amp;&amp; strategy.precs.blocksize != 1
            strategy.precs.blocksize = nspec
        end
    end
    control = SolverControl(method_linear = strategy)
    control.maxiters = 500
    u = solve(sys; verbose, control, log = true)
    return norm(u)
end

using Test
function runtests()

    if Sys.isapple()
        return nothing
        # MacOS14 currently crashes here:
        # OMP: Error #13: Assertion failure at kmp_runtime.cpp(8114).
        # MacOS13 may crash here:
        # OMP: Error #13: Assertion failure at kmp_csupport.cpp(607).
    end

    strategies = [
        (method = UMFPACKFactorization(), dims = (1, 2, 3)),
        (method = KrylovJL_GMRES(precs = LinearSolvePreconBuilder(UMFPACKFactorization())), dims = (1, 2, 3)),
        (method = KrylovJL_GMRES(precs = BlockPreconBuilder(precs = LinearSolvePreconBuilder(UMFPACKFactorization()))), dims = (1, 2, 3)),
        (method = KrylovJL_GMRES(precs = BlockPreconBuilder(precs = AMGPreconBuilder())), dims = (2, 3)),
        (method = KrylovJL_BICGSTAB(precs = BlockPreconBuilder(precs = AMGPreconBuilder())), dims = (2,)),
        (method = KrylovJL_GMRES(precs = BlockPreconBuilder(precs = ILUZeroPreconBuilder())), dims = (2, 3)),
        (method = KrylovJL_GMRES(precs = ILUZeroPreconBuilder(blocksize = 5)), dims = (1, 2)),
    ]

    dimtestvals = [4.788926530387466, 15.883072449873742, 52.67819183426213]
    for dim in [1, 2, 3]
        for assembly in [:edgewise, :cellwise]
            for flux in [:flux_marray, :flux_strided, :flux_diffcache]
                for strategy in strategies
                    if dim in strategy.dims
                        result = main(; dim, assembly, flux, strategy = strategy.method) ≈ dimtestvals[dim]
                        if !result
                            @show dim, assembly, flux, strategy
                        end
                        @test result
                    end
                end
            end
        end
    end

    for dim in [2]
        for assembly in [:edgewise, :cellwise]
            for flux in [:flux_marray, :flux_strided, :flux_diffcache]
                result = main(; dim, n = 100, assembly, flux, npart = 20)
                @test  result ≈ 141.54097792523987
            end
        end
    end
    return nothing
end

end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../DevEx004_EquationBlock3D/">« 004: 3D Nonlinear Reaction-Diffusion System with Coupled Species</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.0 on <span class="colophon-date" title="Wednesday 19 November 2025 23:04">Wednesday 19 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
